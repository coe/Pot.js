<div>
 <div>
   <h2 id="manualsub.Deferred.Reference.Reference" class="potjs-manual-item-for-in-view">Deferred Reference</h2>
   <div class="potjs-manual-item-for-in-view">
    <p>
     Hereafter this section describes about the Pot.Deferred.
    </p>
   </div>
   <h3 id="manualsub.Deferred.Reference.callbackChain" class="potjs-manual-item-for-in-view">Callback Chain</h3>
   <div class="potjs-manual-item-for-in-view">
    <p>
     Pot.Deferred is asynchronous library that makes
      it possible to write asynchronous JavaScript callback processes serially.
    </p>
    <pre>setTimeout(function() {
    something1();
    setTimeout(function() {
        something2();
        setTimeout(function() {
            something3();
        }, 0);
    }, 0);
}, 0);</pre>
    <p>
     This nested process makes like able to write as follows:
    </p>
    <pre>begin(something1).then(something2).then(something3);</pre>
    <p>
     <br>
    </p>
    <p>
     Try writing a simple asynchronous processing using Pot.Deferred.
    </p>
    <pre>begin(function() {
    console.log('begin');
    return wait(2);
}).then(function() {
    console.log('end');
});</pre>
    <p>
     This process begins by asynchronously &quot;begin&quot; method.
     Output 'begin' first in the console and will output 'end' after waits 2 seconds.
    </p>
    <p>
     If Pot.globalize() is not called, this example same as following code.
    </p>
    <pre>Pot.Deferred.begin(function() {
    console.log('begin');
    return Pot.Deferred.wait(2);
}).then(function() {
    console.log('end');
});</pre>
    <p>
     <br>
    </p>
    <p>
     (Hereafter, this reference describes as the environment
      that is called Pot.globalize() for convenience.)
    </p>
    <div>
     <p>
      If you have experience in the Deferred other libraries,
       the following confirm the difference in the function name.
       (There are also several different interpretations.)
     </p>
     <div>
       <table class="grid" id="manualsub.Deferred.Reference.DeferredLibraryMap">
         <tr>
           <td class="row-head marker">
             <a href="http://polygonplanet.github.com/Pot.js/index.html"
                title="Pot.js + PotLite.js - Document And Reference - JavaScript Async + Utility Library">Pot.Deferred</a>
           </td>
           <td class="row-head">
             <a href="http://mochi.github.com/mochikit/doc/html/MochiKit/Async.html#fn-deferred"
                title="MochiKit.Async - manage asynchronous tasks">MochiKit.Async.Deferred</a>
           </td>
           <td class="row-head">
             <a href="http://cho45.stfuawsc.com/jsdeferred/"
                title="JSDeferred - cho45.stfuawsc.com">JSDeferred</a>
           </td>
           <td class="row-head">
             <a href="http://api.jquery.com/category/deferred-object/"
                title="Deferred Object -- jQuery API">jQuery.Deferred</a>
           </td>
           <td class="row-head">
             <a href="http://docs.dojocampus.org/dojo/Deferred"
                title="dojo/Deferred - DojoCampus - Docs">dojo.Deferred</a>
           </td>
         </tr>
         <tr>
           <td class="marker">then</td>
           <td>addCallback(s)</td>
           <td>next</td>
           <td>done / then</td>
           <td>then / addCallback(s)</td>
         </tr>
         <tr>
           <td class="marker">rescue</td>
           <td>addErrback</td>
           <td>error</td>
           <td>fail</td>
           <td>addErrback</td>
         </tr>
         <tr>
           <td class="marker">ensure</td>
           <td>addBoth</td>
           <td>-</td>
           <td>always</td>
           <td>addBoth</td>
         </tr>
         <tr>
           <td class="marker">begin</td>
           <td>callback</td>
           <td>call</td>
           <td>resolve</td>
           <td>resolve / callback</td>
         </tr>
         <tr>
           <td class="marker">raise</td>
           <td>errback</td>
           <td>fail</td>
           <td>reject</td>
           <td>reject / errback</td>
         </tr>
         <tr>
           <td class="marker">cancel</td>
           <td>cancel</td>
           <td>cancel</td>
           <td>-</td>
           <td>cancel</td>
         </tr>
       </table>
     </div>
    </div>
    <p>
     Pot.Deferred is almost the same behavior as the JSDeferred and the MochiKit.Async.Deferred.
    </p>
    <p>
     <br>
    </p>
    <p>
     This description is referred from 
      <a href="http://cho45.stfuawsc.com/jsdeferred/doc/intro.en.html"
         title="Introduction to JSDeferred">JSDeferred document</a> 
      about the basic reference of the Deferred.
    </p>
    <p>
     Asynchronous processing also occurs during events such as onclick
      as well as Ajax and setTimeout.
     <br>
     For example, there is a function for HTTP request,
     URL as its first argument,
     and shall require a second argument to the callback function.
     <br>
     If it write without the Deferred, like below.
    </p>
    <pre>request('/foo.json', function(fooData) {
    request('/bar.json', function(barData) {
        request('/baz.json', function(bazData) {
            alert([fooData.result, barData.result, bazData.result]);
        });
    });
});</pre>
    <p>
     The more request and will become deeply nested function.
    </p>
    <p>
     If it write with Pot.Deferred this looks like below.
    </p>
    <pre>// Assume &quot;request&quot; function requires a URL as first argument
//  and returns a new instance of Deferred.
var result = [];
begin(function() {
    return request('/foo.json').then(function(fooData) {
        result.push(fooData.result);
    });
}).then(function() {
    return request('/bar.json').then(function(barData) {
        result.push(barData.result);
    });
}).then(function() {
    return request('/baz.json').then(function(bazData) {
        result.push(bazData.result);
    });
}).then(function() {
    alert(result);
});</pre>
    <p>
     Compared with cases without the Deferred, makes callback processes serially.
    </p>
    <p>
     However, in this case, repeat the process has closed as well.
     <br>
     The following example can be process any requests.
    </p>
    <pre>var urls = ['/foo.json', '/bar.json', '/baz.json'];
var result = [];
Deferred.forEach(urls, function(url) {
    return request(url).then(function(data) {
        result.push(data);
    });
}).then(function() {
    alert(result);
});</pre>
    <p>
     You can write like this.
    </p>
    <p>
     You can write this as more compact and parallel processing, like below.
    </p>
    <pre>parallel([
    request('/foo.json'),
    request('/bar.json'),
    request('/baz.json')
]).then(function(result) {
    alert(result);
});</pre>
    <p>
     Thus, <em>&quot;parallel&quot;</em> (Pot.Deferred.parallel) can also be used.
     <em>&quot;parallel&quot;</em> works comparable with the DeferredList in MochiKit 
      and the JSDeferred.parallel method.
     After all processing then callback is called with results.
    </p>
    <p><br></p>
    <p>
     The result of the callback function for each chain is passed as
      an argument to the next value chain by &quot;return&quot; statement.
     <br>
     If callback function has no &quot;return&quot; statement, 
      will be ignored as the result.
     <br>
     In that case, the following is passed to the callback again took over the previous results.
     <br>
     Determine whether there is the &quot;return&quot; statement
      to directly under the callback function scope.
    </p>
    <pre>begin(function() {
    return 'foo';
}).then(function(res) {
    alert(res); // 'foo'

    // Exit this callback without return value.

}).then(function(res) {
    // Taken over the result of the previous chain.
    alert(res); // 'foo'

    // Returns a value.
    return 'bar';
}).then(function(res) {
    alert(res); // 'bar'
});</pre>
   </div>
   <h3 id="manualsub.Deferred.Reference.exception" class="potjs-manual-item-for-in-view">Exception</h3>
   <div class="potjs-manual-item-for-in-view">
    <p>
     Exceptions that occur in asynchronous processing, 
      but you will behave as if nothing had happened.
    </p>
    <p>
     Pot.Deferred is able to caught this error by &quot;<em>rescue</em>&quot; method.
    </p>
    <pre>begin(function() {
    alert('begin');
}).then(function() {
    // Occurs an exception by calling an undefined function.
    undefinedFunc.call();
}).rescue(function(err) {
    // Catch the error.
    alert(err);
}).then(function() {
    // Then process can continue callbacks.
    alert('end');
});</pre>
    <p>
     Broadly, this can be handled in such flows.
    </p>
    <p>
     Caught by &quot;<em>rescue</em>&quot;, 
       you can always catch the error even though not next chain.
    </p>
    <pre>begin(function() {
    alert(1);
    return 1 + 1;
}).then(function(res) {
    alert(res); // 2
    return res + 1;
}).then(function(res) {
    alert(res); // 3

    // Raise an error.
    throw new Error('error');
}).then(function(res) {
    // This callback will be not called by occurs an error.
    alert(res);
    return res + 1;
}).rescue(function(err) {
    // Catch the error.
    alert(err);
    return 'end';
}).then(function(res) {
    alert(res); // 'end'
});</pre>
   <p>
    This example will be alert 1, 2, 3, 'error', 'end'.
   </p>
   <p>
    &quot;<em>then</em>&quot; function's callback function of first argument 
    will be called if succeed.
    If occurs an error then callback function will be ignored.
   </p>
   <p><br></p>
   <p>
    In fact, careful implementation such as all
     chains with &quot;<em>rescue</em>&quot; will so rare.
    <br>
    So you might not notice that completed implementation with exception possibility on.
    <br>
    For such case,
    Pot.Deferred will be re-throw when the chain terminated with uncatched error.
    <br>
    This re-throw feature, the exception can be implemented without missing.
   </p>
   <p><br></p>
   <p>
    You can use &quot;<em>ensure</em>&quot; method on both success and exceptional cases, 
    even if you want to execute a next callback function in any event.
   </p>
   <pre>begin(function() {
    return 1;
}).then(function(res) {
    alert(res);
    // Raise an exception at random.
    if (Math.random() * 10 &lt; 5) {
        throw new Error('error');
    } else {
        return res + 1;
    }
}).ensure(function(res) {
    if (isError(res)) {
        alert('Error: ' + res);
    } else {
        alert('Success: ' + res);
    }
    return 'end';
}).then(function(res) {
    alert(res); // 'end'
});</pre>
    <p>
     &quot;<em>ensure</em>&quot; is usefull such a success or unknown case,
      or when you want to execute always.
    </p>
    <p>
     isError (Pot.isError) function checks whether argument is an Error object.
    </p>
    <p>
     &quot;then&quot;, &quot;rescue&quot; and &quot;ensure&quot; each use the same.
     <br>
     Returned value will use for the next callback function's argument.
    </p>
    <p>
     If returned value is an instance of the Pot.Deferred 
       then last callback chain's returned value passed to the next callback function argument.
    </p>
    <pre>begin(function() {
    return begin(function() {
        return 'ho';
    }).then(function(res) {
        var d = new Deferred();
        return d.then(function() {
            return res + 'ge';
        }).begin();
    });
}).then(function(res) {
    alert(res);
});</pre>
    <p>
     This example will alert 'hoge'.
    </p>
    <p>
     You can nested chain when returned value is an instance of  Pot.Deferred.
    </p>
   </div>
   <h3 id="manualsub.Deferred.Reference.Destructuring-Assignment" class="potjs-manual-item-for-in-view">Destructuring-Assignment</h3>
   <div class="potjs-manual-item-for-in-view">
    <p>
     Pot.Deferred's callback chain can Destructuring-Assignment like.
    </p>
    <pre>begin(function() {
    // Return as Array
    return [1, 2, 3];

// Match the number of arguments and number of items in an array of results.
}).then(function(a, b, c) {

    debug(a); // 1
    debug(b); // 2
    debug(c); // 3

    return [c, b, a]; // Returns a reverse order

}).then(function(a, b, c) {
    // Be reversed and

    debug(a); // 3
    debug(b); // 2
    debug(c); // 1

    return [c, b, a];

}).then(function(res) { // As usual, gets one argument variable.
    // If you specify one argument variable Destructuring-Assignment will not execute.

    debug(res); // [1, 2, 3]

});</pre>
    <p><br></p>
   </div>
   <h3 id="manualsub.Deferred.Reference.speedControl" class="potjs-manual-item-for-in-view">Speed Control</h3>
   <div class="potjs-manual-item-for-in-view">
    <p>
     Pot.Deferred can control the execution speed of callback chain.
    </p>
    <pre>var d = new Deferred();
// Speed down
d.speed('slow');

d.then(function() {
    console.log(1);
}).then(function() {
    console.log(2);
}).then(function() {
    console.log(3);
}).begin();</pre>
    <p>
     
     
     
     
     
     <h1 class="error">途中...<br>The translation is still going on...</h1>
     
     
     
     
     
     こうすることで、各コールバックはゆっくり実行されます。
     <br>
     この例では、console.log() が 1, 2, 3 とゆっくり表示されます。
    </p>
    <p>
     速度の指定は、speed メソッドにより指定できます。
     定義された値の文字列、または数値 (ms) で指定できます。
     定義された文字列値は 下の表 を参照ください。
    </p>
    <div>
     <table class="grid" id="manualsub.Deferred.Reference.controlSpeedMap">
      <tr>
       <td class="marker row-head">値 / メソッド名</td>
       <td class="marker row-head">速度</td>
      </tr>
      <tr>
       <td>limp</td>
       <td>最も遅い</td>
      </tr>
      <tr>
       <td>doze</td>
       <td>遅い</td>
      </tr>
      <tr>
       <td>slow</td>
       <td>遅め</td>
      </tr>
      <tr>
       <td>normal</td>
       <td>通常</td>
      </tr>
      <tr>
       <td>fast</td>
       <td>速め</td>
      </tr>
      <tr>
       <td>rapid</td>
       <td>速い</td>
      </tr>
      <tr>
       <td>ninja</td>
       <td>最も速い</td>
      </tr>
     </table>
    </div>
    <p>
     または、コンストラクタに引数のオプションとして渡すことができます。
    </p>
    <pre>var d = new Deferred({ speed : 'slow' });</pre>
    <p>
     コールバックチェインの途中で速度を変更することも可能です。
    </p>
    <pre>var d = new Deferred();
d.then(function() {
    console.log(1);
}).speed('slow').then(function() {
    console.log(2);
    return 2 + 1;
}).speed(5000).then(function(res) {
    console.log(res); // 3
}).begin();</pre>
    <p>
     上の例のように、コールバック関数を用いないメソッドは
     結果の値を引き継ぎ、次のコールバックに渡します。
     <br>
     したがって、speed() や wait() などを使用しても
     次のコールバックに渡す引数の値が失われることはありません。
    </p>
    <p>
     何らかの重い処理を分割して処理する場合、speed の指定により負荷を軽減できます。
    </p>
    <pre>begin(function() {
    return someHeavyProcess();
}).speed('slow').then(function(res) {
    return moreHeavyProcess(res);
}).speed('doze').then(function(res) {
    return mostHeavyProcess(res);
}).speed('normal').then(function(res) {
    alert(res);
});</pre>
    <p>
     途中で wait を置くことも可能です。
    </p>
    <pre>begin(function() {
    return someHeavyProcess();
}).speed('slow').wait(1).then(function(res) {
    return moreHeavyProcess(res);
}).speed('doze').wait(2).then(function(res) {
    return mostHeavyProcess(res);
}).speed('normal').then(function(res) {
    alert(res);
});</pre>
    <p>
     wait は、秒数を引数に設定します。
     ミリ秒ではないので注意してください。
    </p>
   </div>
   <h3 id="manualsub.Deferred.Reference.fireChain" class="potjs-manual-item-for-in-view">チェインを実行</h3>
   <div class="potjs-manual-item-for-in-view">
    <p>
     今までの例の途中でもいくつか出ましたが、
     <br>
     .begin() メソッドによりチェインを開始することができます。
    </p>
    <p>
     関数としての begin (Pot.Deferred.begin) は、
     Deferred のインスタンスを生成し、
     チェインを開始するショートカットのようなものです。
     別ものなので注意してください。
    </p>
    <pre>var d = new Deferred();
d.then(function() {
    alert('hoge');
});</pre>
    <p>
     この例は、何も実行されません。
     'hoge' とアラートもされません。
     <br>
     単に変数 d にコールバックを登録しただけです。
    </p>
    <p>
     これを実行するには、
    </p>
    <pre>d.begin();</pre>
    <p>
     とすると、コールバックチェインが開始されます。
    </p>
    <p>
     また、引数に値を設定することができます。
    </p>
    <pre>var d = new Deferred();
d.then(function(value) {
    alert(value);
}).begin('hoge');</pre>
    <p>
     この例では、hoge とアラートされます。
    </p>
    <p>
     次 (この場合は最初) のコールバックの引数の値として渡すことができます。
    </p>
    <p>
     また、何らかの事態により .begin を通常処理ではなくエラーと扱いたい場合は、
    </p>
    <pre>var d = new Deferred();
d.then(function() {
    // 成功時
    successFunc();
}).rescue(function() {
    // エラー時
    errorFunc();
}).ensure(function() {
    // 最終的な処理
    finallyFunc();
});

// チェックが通れば成功とする場合
if (check()) {
    d.begin();
} else {
    d.raise();
}</pre>
    <p>
     このような分岐が必要な場合、
     .begin() のかわりに .raise() を実行することで
     エラー扱いでコールバックチェインを開始することができます。
     <br>
     エラーから始まるので、最初に then があった場合は そのコールバックは無視されます。
    </p>
    <p>
     .raise() も同様に、引数に何らかの値を与え
     次のエラーバック関数の引数として渡すことができます。
    </p>
   </div>
   <h3 id="manualsub.Deferred.Reference.replaceToDeferred" class="potjs-manual-item-for-in-view">関数を Deferred 化</h3>
   <div class="potjs-manual-item-for-in-view">
    <p>
     既存の関数や、ユーザー定義の関数を Deferred 化、
     つまり Pot.Deferred のインスタンスが返るよう置き換えたり
     自分で作成する必要がでてくるかもしれません。
    </p>
    <p>
     例として、XMLHttpRequest を使った非同期処理を書いてみます。
    </p>
    <pre>function request(url, options) {
    var deferred = new Deferred();
    var xhr = new XMLHttpRequest();
    if (options.queryString) {
        url += options.queryString;
    }
    xhr.open(options.method, url, true);
    xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
            if (xhr.status == 200) {
                deferred.begin(xhr);
            } else {
                deferred.raise(xhr);
            }
        }
    };
    deferred.canceller(function() {
        xhr.abort();
    });
    xhr.send(options.sendContent || null);
    return deferred;
}</pre>
    <p>
     request 関数は、上のほうで例としてあげたものですが、
     PotLite.js 内にも定義されています。
     <br>
     この例は、それを簡略化したものです。
    </p>
    <p>
     Deferred を返すには、new Deferred としたものや、
     Pot.Deferred.begin() のような
     あらかじめ定義されていて Deferred を返す関数を利用する必要があります。
    </p>
    <p>
     接続が成功したら begin() を、失敗したら raise() をコールしています。
     <br>
     関数を定義する場合、エラー処理を明示してあげることで
     より適切な処理になります。
    </p>
    <p>
     また、canceller() によりキャンセル処理を追加しています。
     <br>
     Deferred のキャンセルは、
    </p>
    <pre>deferred.cancel();</pre>
    <p>
     とすることで任意にコールバックチェインの実行を中止
     または中断できます。
    </p>
    <p>
     Pot.Deferred では、キャンセル処理としてのコールバック関数を
     スタッカブルに保持します。
     <br>
     なので、canceller() メソッドにより複数のコールバックが登録できます。
    </p>
    <p>
     PotLite.js では、request 関数のほかに
     jsonp 関数も定義されています。
     <br>
    </p>
    <p>
     jsonp 関数は、そのままの意味で JSONP によるデータ取得を行います。
    </p>
    <p>
     使用方法、引数などは request, jsonp 共にほぼ同じで
     返り値に XHR を設定された Deferred を返します。
    </p>
    <p><br></p>
    <p>
     他にも関数を Deferred 化するための方法があり、
     <br>
     deferrize (Pot.Deferred.deferrize) という関数が Pot.Deferred オブジェクトに定義されています。
    </p>
    <pre>// setTimeout を Deferred 化する
var timer = deferrize(window, 'setTimeout');

// setTimeout と同じ引数
timer(function() {
    debug(1);
}, 5000).then(function() {
    debug(2);
});</pre>
    <p>
     上の例は、setTimeout を Deferred 化し、それを実行します。
    </p>
    <p>
     5 秒待ってから、
     debug 関数によりコンソールに 1, 2 と出力されます。
    <p>
     deferrize はコールバック関数を引数とする場合は、
     その関数の処理が終わった後に Deferred を開始し、
     関数を引数として扱わないものは
     処理が全て終わったあとに Deferred を開始します。
     途中でエラーが起きると raise() により開始されます。
     <br>
     したがって、処理自体を置き換えたい場合でなければ
     大抵の関数は deferrize で Deferred 化できます。
    </p>
    <p>
     もっと複雑な置き換えをする場合や、
     自前で Deferred 関数を作成したりする場合、
     new Deferred や Pot.Deferred オブジェクトの関数などを使用して
     より細かな処理を独自に作成することができます。
    </p>
   </div>
   <h3 id="manualsub.Deferred.Reference.iterator" class="potjs-manual-item-for-in-view">イテレータ</h3>
   <div class="potjs-manual-item-for-in-view">
    <p>
     Pot.js は、MochiKit ライクな実装の Deferred を中心に
     非同期のループ、イテレートを重視して作られています。
     <br>
     (ここで言う MochiKit ライクとは、
      コールバックチェインがひとつのインスタンスであるということです。)
    </p>
    <p>
     また、JSDeferred の概要を強く尊重しています。
    </p>
    <p>
     <a href="http://cho45.stfuawsc.com/jsdeferred/doc/intro.html"
        title="JSDeferred 紹介">JSDeferred 紹介</a> より引用：
    </p>
    <blockquote>
     <p>
      JavaScript における「高速化」
     </p>
     <p>
      JavaScript における「高速化」では、単純に処理速度の高速化というよりは、
      ユーザ体験のストレスをいかになくすかがとても重要です。
     </p>
    </blockquote>
    <p>
     いくつにもネストした JavaScript のループ (for, for-in, while など) は、
     <br>
     特に Web ブラウザ上で実行される場合
     処理が重たくなりがちです。
    </p>
    <p>
     そこで、Pot.js は、非同期処理を直列的に書けるようにする Deferred を活用し、
     <br>
     forEach, map, reduce, filter, some, every, repeat, forEver 
     などといったイテレート関数と結びつけ、
     <br>
     各ループ間の処理の重さを計算し、
     自動的に CPU 負荷が軽減するよう調整しています。
     <br>
     そして、更なるストレス軽減を目標としています。
    </p>
    <p>
     イテレートは、同期または非同期、Deferred チェイン上などで実行が可能です。
    </p>
    <p>
     同期でのシンプルなオブジェクトのイテレートの場合、for-in では
    </p>
    <pre>for (var key in object) {...}</pre>
    <p>
     となりますが、Pot.js の forEach を使うと、
    </p>
    <pre>forEach(object, function(value, key) {...});</pre>
    <p>
     となります。
     <br>
     非同期でループする場合は、
    </p>
    <pre>Deferred.forEach(object, function(value, key) {...})</pre>
    <p>
     となり、Pot.Deferred のインスタンスを返します。
     Pot.globalize() してない場合は Pot.Deferred.forEach です。
    </p>
    <p>
     Deferred チェイン上で実行する場合も同じ扱いですが、引数が異なります。
    </p>
    <pre>(new Deferred()).forEach(function(value, key) {...}).begin([1, 2, 3]);</pre>
    <p>
     各ループは、コールバック関数の処理の重さにより負荷がかからないよう
     自動調節します。
     <br>
     この処理をすることで、例えば 10000 程の多くのアイテム数を持つ配列に対して
     for でループした場合と
     Deferred.forEach などのイテレータで実行した場合、
     <br>
     全体の処理の重さは大きな差が出ます。
     <br>
     また、それにより Web ブラウザによって発行される、
     <br>
     「処理が重くなっています、中断しますか？」
     などのメッセージを回避することもできます。
    </p>
    <p>
     Deferred に関連する イテレータのすべては、速度を調整することができます。
     <br>
     各ループをゆっくり実行したい場合は、
    </p>
    <pre>Deferred.forEach.slow(obj, function() {...});</pre>
    <p>
     逆に速くしたい場合は、
    </p>
    <pre>Deferred.forEach.fast(obj, function() {...});</pre>
    <p>
     などの指定が可能です。
     <br>
     他には 遅い順に limp, doze, slow, normal, fast, rapid, ninja が指定可能です。
     速度の指定値については、<a href="#manualsub.Deferred.Reference.controlSpeedMap">上の速度の表</a> を参照ください。
     <br>
     その場に応じて使い分けができます。
    </p>
    <p>
     時間のかかるループだけでなく、
     <br>
     瞬間的に負荷がかかり
     Web ブラウザが頻発して一瞬だけ固まる、といった事例もあげられます。
     <br>
     そのような処理も、1 回で済まそうとしないで分割することで解消できます。
    </p>
    <p>
     例えば DOM 要素を大量に扱って操作する場合、
    </p>
    <pre>// ものすごい巨大なページだったとします。
var elems = document.getElementsByTagName('*');</pre>
    <p>
     従来通りループする場合、
    </p>
    <pre>var len = elems.length;
for (var i = 0; i &lt; len; i++) {
    var elem = elems[i];
    someHeavyProcess(elem); // 何らかの重い処理
}</pre>
    <p>
     この方法では休む間を与えられず、UI が固まっていても容赦なく処理が続行されてしまいます。
    </p>
    <p>
     これを Pot.Deferred を使って書くと、
    </p>
    <pre>Deferred.repeat(elems.length, function(i) {
    var elem = elems[i];
    someHeavyProcess(elem); // 何らかの重い処理
});</pre>
    <p>
     一見あまり変化なさそうですが、
     1 ループごとに処理の負荷を計算して
     ある程度重いと判断した場合は Web ブラウザに制御を返し、
     UI を独占しないよう調節します。
    </p>
    <p>
     または、forEach を使うこともできます。
    </p>
    <pre>Deferred.forEach(elems, function(elem) {
    someHeavyProcess(elem); // 何らかの重い処理
});</pre>
    <p>
     someHeavyProcess() と 1 つの関数だけで表現しましたが、
     <br>
     これが、someHeavyProcess1, someHeavyProcess2, ... と
     いくつかの関数で構成されている場合、
    </p>
    <pre>Deferred.forEach(elems, function(elem) {
    return begin(function() {
        someHeavyProcess1(elem);
    }).wait(1).then(function() {
        someHeavyProcess2(elem);
    }).wait(1).then(function() {
        someHeavyProcess3(elem);
    });
});</pre>
    <p>
     このように分割し、任意に wait などを入れることが可能です。
    </p>
    <p>
     なお、begin (Pot.Deferred.begin) は、
     Pot.Deferred オブジェクトのインスタンスを返すので
     Deferred.forEach などの中で実行する場合、
     return が必要です。
     return しないと整合性がとれなくなってしまいます。
    </p>
    <p>
     それでも重い場合、
    </p>
    <pre>Deferred.forEach.slow(elems, function(elem) {
    someHeavyProcess(elem);
});</pre>
    <p>
     ゆっくり実行することを明示し slow を指定して速度を調整できます。
    </p>
    <p>
     slow の次に遅い doze にすると、必ず毎回のループごとに
     Web ブラウザに制御を返します。
     <br>
     結果として処理時間は長くなりますが、
     途中で固まったりカクカクするようなことが避けられます。
    </p>
    <p>
     速度指定は 'メソッド.速度()' の形式で利用できます。
     <br>
     例えば、 'forEach.rapid(...)' のような指定です。
     <br>
     forEach, repeat, map, filter など、すべてのイテレータで指定可能です。
    </p>
    <p>
     定義された速度の値は、<a href="#manualsub.Deferred.Reference.controlSpeedMap">上の速度の表</a> を参照してください。
    </p>
    <p>
     速度指定の表にある 「最も速い」 という表記は、
     <br>
     逆に言うと
     最も負荷をかけやすいとも言えます。
     <br>
     とはいっても for-in などでループすることと比べたら
     UI への配慮は少なからず存在するという差はあります。
    </p>
    <p>
     大抵は自ら速度調整する必要はありませんが、
     特殊な用途やデバッグ時など、必要になることもあります。
    </p>
   </div>
   <h3 id="manualsub.Deferred.Reference.replaceLoop" class="potjs-manual-item-for-in-view">ループ処理を置き換える</h3>
   <div class="potjs-manual-item-for-in-view">
    <p>
     既存のループで負荷がかかっている処理を、
     Pot.js のイテレータを用いて軽減させることができます。
    </p>
    <pre>function someLoop(n, c) {
    var results = [];
    for (var i = 0; i &lt; n; i++) {
        var array = [];
        for (var j = 0; j &lt; c; j++) {
            array[j] = j;
        }
        results[i] = array;
    }
    return results;
}</pre>
    <p>
     例えばこのような関数があったとします。
     <br>
     引数 c 回ループした配列を引数 n 個分持つ配列を返す関数です。
    </p>
    <p>
     例えばこれを、
    </p>
    <pre>var array = someLoop(100000, 1000);</pre>
    <p>
     このような大きい配列を作るとなると、
     スペックにもよりますが、
     瞬間的な負荷は大きくなり UI を独占してしまうでしょう。
    </p>
    <p>
     この関数を Deferred 化してみます。
    </p>
    <pre>function someLoopDefer(n, c) {
    var results = [];
    return Deferred.repeat(n, function(i) {
        var array = [];
        for (var j = 0; j &lt; c; j++) {
            array[j] = j;
        }
        results[i] = array;
    }).then(function() {
        return results;
    });
}</pre>
    <p>
     例として、このようになります。
     <br>
     内側の for はこのままでいいのかと思うかもしれませんが、
     おそらく repeat、Deferred.repeat 等に変えたところで
     必要以上に負荷が分散され、結果としてかなり速度は落ちてしまうでしょう。
     <br>
     なので、いちばん外側のループのみを置き換えます。
     <br>
     もっとも、この例の場合は
     内側の for を何度も実行する必要はありませんが、
     あくまで例として捉えてください。
     <br>
     返り値は Deferred になります。
    </p>
    <pre>someLoopDefer(100000, 1000).then(function(res) {
    var array = res;
});</pre>
    <p>
     Deferred が返るので、then などで結果を取得します。
     そのままチェインを繋げることもできます。
    </p>
    <p>
     この変化により、瞬間的な処理の重さが分散され
     安定した処理が可能となります。
     <br>
     そのかわり、処理時間は若干伸びる可能性があります。
    </p>
    <p>
     Pot.Deferred のイテレータを使う場合、
     このように
     あまり意識せずに分散的なループが可能となります。
    </p>
   </div>
   <h3 id="manualsub.Deferred.Reference.StopIteration" class="potjs-manual-item-for-in-view">イテレートを止める</h3>
   <div class="potjs-manual-item-for-in-view">
    <p>
     Pot.js, PotLite.js で実装されている
     すべてのイテレータは、
     <br>
     StopIteration を throw することで中断できます。
    </p>
    <pre>var foo = '';
forEver(function(i) {
    foo += 'foo';
    if (foo.length &gt; 10) {
        throw StopIteration;
    }
});

debug(foo);</pre>
    <p>
     この例は、debug 関数により
     コンソールに 'foofoofoofoo' と出力されます。
    </p>
    <p>
     forEver (Pot.forEver) は、StopIteration が throw されるまで
     永遠にループします。
     <br>
     複雑な条件式でループを制御する場合や、
     そのような既存の重い処理を
     Deferred.forEver で置き換えたい場合などに活用できます。
    </p>
    <p>
     StopIteration は、 Array.prototype.forEach が有効な環境など、
     コンフリクトする可能性があるときは
     Pot.StopIteration と明示することで解消できます。
    </p>
    <p>
     StopIteration を判別する方法は、
    </p>
    <pre>if (isStopIter(e)) {...}</pre>
    <p>
     または、
    </p>
    <pre>if (e == StopIteration) {...}</pre>
    <p>
     と単純に比較か、
    </p>
    <pre>if (e instanceof StopIteration) {...}</pre>
    <p>
     とすることもできます。
    </p>
    <p>
     おそらく Pot.js ライブラリが実装している
     isStopIter (Pot.isStopIter) が確実です。
    </p>
    <p><br></p>
    <p>
     実装されているすべてのイテレータは、
     コールバック関数が非同期の Deferred オブジェクトを
     いくつにもネストしたとしても、
     <br>
     throw StopIteration によりスコープ間を超えて
     実行中のイテレータ関数のスコープまで届くよう設計されています。
    </p>
    <pre>var result = [];
begin(function() {
    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
}).forEach(function(value) {
    return begin(function() {
        var d = new Deferred();
        return d.then(function() {
            if (value &gt; 5) {

                // 実行しているイテレータのスコープが対象になるため
                // この例では いちばん外側の .forEach まで届く

                throw StopIteration;
            }
            return value * 100;
        }).begin();
    }).then(function(res) {
        result.push(res);
    });
}).then(function() {
    debug(result);
    //  =&gt;  [100, 200, 300, 400, 500]
});</pre>
   </div>
 </div>
</div>