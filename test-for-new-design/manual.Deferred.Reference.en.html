<!DOCTYPE html>
<html dir="ltr">
<head>
<meta charset="UTF-8">
<meta http-equiv="refresh" content="0; URL=./#manual.Deferred.Reference">
<title>Pot.js Deferred Reference</title>
<link rel="Pot.js Repository - GitHub" href="http://github.com/polygonplanet/Pot.js">
<link rel="author" title="polygon planet" href="http://polygonpla.net/">
<script type="text/javascript">
location.href = './#manual.Deferred.Reference';
</script>
</head>
<body>
<h1>Pot.js Deferred Reference</h1>
<div class="pot-js-document-reference-content-container">
<!--#Pot.js-reference-content:{{{-->

<div>
 <div>
   <h2 id="manualsub.Deferred.Reference.Reference" class="potjs-manual-item-for-in-view">Deferred Reference</h2>
   <div class="potjs-manual-item-for-in-view">
    <p>
     Hereafter this section describes about the <a href="#reference.Pot.Deferred.methods">Pot.Deferred</a>.
    </p>
   </div>
   <h3 id="manualsub.Deferred.Reference.callbackChain" class="potjs-manual-item-for-in-view">Callback Chain</h3>
   <div class="potjs-manual-item-for-in-view">
    <p>
     <a href="#reference.Pot.Deferred.methods">Pot.Deferred</a> is asynchronous processing object that makes
      it possible to write asynchronous JavaScript callback processes serially.
    </p>
    <pre>setTimeout(function() {
    something1();
    setTimeout(function() {
        something2();
        setTimeout(function() {
            something3();
        }, 0);
    }, 0);
}, 0);</pre>
    <p>
     This nested process makes like able to write as follows:
    </p>
    <pre>begin(something1).then(something2).then(something3);</pre>
    <p>
     <br>
    </p>
    <p>
     Try writing a simple asynchronous processing using Pot.Deferred.
    </p>
    <pre>begin(function() {
    console.log('begin');
    return wait(2);
}).then(function() {
    console.log('end');
});</pre>
    <p>
     This process begins by asynchronously &quot;<a href="#reference.function.Pot.Deferred.begin">begin</a>&quot; method.
     Output 'begin' first in the console and will output 'end' after waits 2 seconds.
    </p>
    <p>
     If <a href="#reference.function.Pot.globalize">Pot.globalize()</a> is not called, this example same as following code.
    </p>
    <pre>Pot.Deferred.begin(function() {
    console.log('begin');
    return Pot.Deferred.wait(2);
}).then(function() {
    console.log('end');
});</pre>
    <p>
     <br>
    </p>
    <p>
     (Hereafter, this reference describes as the environment
      that is called <a href="#reference.function.Pot.globalize">Pot.globalize()</a> for convenience.)
    </p>
    <div>
     <p>
      If you have experience in the Deferred other libraries,
       the following confirm the difference in the function name.
       (There are also several different interpretations.)
     </p>
     <div>
       <table class="grid" id="manualsub.Deferred.Reference.DeferredLibraryMap">
         <tr>
           <td class="row-head marker">
             <a href="http://polygonplanet.github.com/Pot.js/index.html"
                title="Pot.js + PotLite.js - Document And Reference - JavaScript Async + Utility Library"><strong>Pot.Deferred</strong></a>
           </td>
           <td class="row-head">
             <a href="http://mochi.github.com/mochikit/doc/html/MochiKit/Async.html#fn-deferred"
                title="MochiKit.Async - manage asynchronous tasks"><strong>MochiKit.Async.Deferred</strong></a>
           </td>
           <td class="row-head">
             <a href="http://cho45.stfuawsc.com/jsdeferred/"
                title="JSDeferred - cho45.stfuawsc.com"><strong>JSDeferred</strong></a>
           </td>
           <td class="row-head">
             <a href="http://api.jquery.com/category/deferred-object/"
                title="Deferred Object -- jQuery API"><strong>jQuery.Deferred</strong></a>
           </td>
           <td class="row-head">
             <a href="http://docs.dojocampus.org/dojo/Deferred"
                title="dojo/Deferred - DojoCampus - Docs"><strong>dojo.Deferred</strong></a>
           </td>
         </tr>
         <tr>
           <td class="marker">then</td>
           <td>addCallback(s)</td>
           <td>next</td>
           <td>done / then</td>
           <td>then / addCallback(s)</td>
         </tr>
         <tr>
           <td class="marker">rescue</td>
           <td>addErrback</td>
           <td>error</td>
           <td>fail</td>
           <td>addErrback</td>
         </tr>
         <tr>
           <td class="marker">ensure</td>
           <td>addBoth</td>
           <td>-</td>
           <td>always</td>
           <td>addBoth</td>
         </tr>
         <tr>
           <td class="marker">begin</td>
           <td>callback</td>
           <td>call</td>
           <td>resolve</td>
           <td>resolve / callback</td>
         </tr>
         <tr>
           <td class="marker">raise</td>
           <td>errback</td>
           <td>fail</td>
           <td>reject</td>
           <td>reject / errback</td>
         </tr>
         <tr>
           <td class="marker">cancel</td>
           <td>cancel</td>
           <td>cancel</td>
           <td>-</td>
           <td>cancel</td>
         </tr>
       </table>
     </div>
    </div>
    <p>
     Pot.Deferred is almost the same behavior as the JSDeferred and the MochiKit.Async.Deferred.
    </p>
    <p>
     <br>
    </p>
    <p>
     This description is referred from 
      <a href="http://cho45.stfuawsc.com/jsdeferred/doc/intro.en.html"
         title="Introduction to JSDeferred">JSDeferred document</a> 
      about the basic reference of the Deferred.
    </p>
    <p>
     Asynchronous processing also occurs during events such as onclick
      as well as Ajax and setTimeout.
     <br>
     For example, there is a function for HTTP request,
     URL as its first argument,
     and shall require a second argument to the callback function.
     <br>
     If it write without the Deferred, like below.
    </p>
    <pre>request('/foo.json', function(fooData) {
    request('/bar.json', function(barData) {
        request('/baz.json', function(bazData) {
            alert([fooData.result, barData.result, bazData.result]);
        });
    });
});</pre>
    <p>
     The more request and will become deeply nested function.
    </p>
    <p>
     If it write with Pot.Deferred this looks like below.
    </p>
    <pre>// Assume &quot;request&quot; function requires a URL as first argument
//  and returns a new instance of Deferred.
var result = [];
begin(function() {
    return request('/foo.json').then(function(fooData) {
        result.push(fooData.result);
    });
}).then(function() {
    return request('/bar.json').then(function(barData) {
        result.push(barData.result);
    });
}).then(function() {
    return request('/baz.json').then(function(bazData) {
        result.push(bazData.result);
    });
}).then(function() {
    alert(result);
});</pre>
    <p>
     Compared with cases without the Deferred, makes callback processes serially.
    </p>
    <p>
     However, in this case, repeat the process has closed as well.
     <br>
     The following example can be process any requests.
    </p>
    <pre>var urls = ['/foo.json', '/bar.json', '/baz.json'];
var result = [];
Deferred.forEach(urls, function(url) {
    return request(url).then(function(data) {
        result.push(data);
    });
}).then(function() {
    alert(result);
});</pre>
    <p>
     You can write like this.
    </p>
    <p>
     You can write this as more compact and parallel processing, like below.
    </p>
    <pre>parallel([
    request('/foo.json'),
    request('/bar.json'),
    request('/baz.json')
]).then(function(result) {
    alert(result);
});</pre>
    <p>
     Thus, <a href="#reference.function.Pot.Deferred.parallel"><em>&quot;parallel&quot;</em> (Pot.Deferred.parallel)</a> can also be used.
     <em>&quot;parallel&quot;</em> works comparable with the DeferredList in MochiKit 
      and the JSDeferred.parallel method.
     After all processing then callback is called with results.
    </p>
    <p><br></p>
    <p>
     The result of the callback function for each chain is passed as
      an argument to the next value chain by &quot;return&quot; statement.
     <br>
     If callback function has no &quot;return&quot; statement, 
      will be ignored as the result.
     <br>
     In that case, the following is passed to the callback again took over the previous results.
     <br>
     Determine whether there is the &quot;return&quot; statement
      to directly under the callback function scope.
    </p>
    <pre>begin(function() {
    return 'foo';
}).then(function(res) {
    alert(res); // 'foo'

    // Exit this callback without return value.

}).then(function(res) {
    // Taken over the result of the previous chain.
    alert(res); // 'foo'

    // Returns a value.
    return 'bar';
}).then(function(res) {
    alert(res); // 'bar'
});</pre>
   </div>
   <h3 id="manualsub.Deferred.Reference.exception" class="potjs-manual-item-for-in-view">Exception</h3>
   <div class="potjs-manual-item-for-in-view">
    <p>
     Exceptions that occur in asynchronous processing, 
      but you will behave as if nothing had happened.
    </p>
    <p>
     Pot.Deferred is able to caught this error by <a href="#reference.function.Pot.Deferred.prototype.rescue">&quot;<em>rescue</em>&quot;</a> method.
    </p>
    <pre>begin(function() {
    alert('begin');
}).then(function() {
    // Occurs an exception by calling an undefined function.
    undefinedFunc.call();
}).rescue(function(err) {
    // Catch the error.
    alert(err);
}).then(function() {
    // Then process can continue callbacks.
    alert('end');
});</pre>
    <p>
     Broadly, this can be handled in such flows.
    </p>
    <p>
     Caught by <a href="#reference.function.Pot.Deferred.prototype.rescue">&quot;<em>rescue</em>&quot;</a>, 
       you can always catch the error even though not next chain.
    </p>
    <pre>begin(function() {
    alert(1);
    return 1 + 1;
}).then(function(res) {
    alert(res); // 2
    return res + 1;
}).then(function(res) {
    alert(res); // 3

    // Raise an error.
    throw new Error('error');
}).then(function(res) {
    // This callback will be not called by occurs an error.
    alert(res);
    return res + 1;
}).rescue(function(err) {
    // Catch the error.
    alert(err);
    return 'end';
}).then(function(res) {
    alert(res); // 'end'
});</pre>
   <p>
    This example will be alert 1, 2, 3, 'error', 'end'.
   </p>
   <p>
    <a href="#reference.function.Pot.Deferred.prototype.then">&quot;<em>then</em>&quot;</a> function's callback function of first argument 
    will be called if succeed.
    If occurs an error then callback function will be ignored.
   </p>
   <p><br></p>
   <p>
    In fact, careful implementation such as all
     chains with <a href="#reference.function.Pot.Deferred.prototype.rescue">&quot;<em>rescue</em>&quot;</a> will so rare.
    <br>
    So you might not notice that completed implementation with exception possibility on.
    <br>
    For such case,
    Pot.Deferred will be <strong>re-throw</strong> when the chain terminated with uncatched error.
    <br>
    This re-throw feature, the exception can be implemented without missing.
   </p>
   <p><br></p>
   <p>
    You can use <a href="#reference.function.Pot.Deferred.prototype.ensure">&quot;<em>ensure</em>&quot;</a> method on both success and exceptional cases, 
    even if you want to execute a next callback function in any event.
   </p>
   <pre>begin(function() {
    return 1;
}).then(function(res) {
    alert(res);
    // Raise an exception at random.
    if (Math.random() * 10 &lt; 5) {
        throw new Error('error');
    } else {
        return res + 1;
    }
}).ensure(function(res) {
    if (isError(res)) {
        alert('Error: ' + res);
    } else {
        alert('Success: ' + res);
    }
    return 'end';
}).then(function(res) {
    alert(res); // 'end'
});</pre>
    <p>
     <a href="#reference.function.Pot.Deferred.prototype.ensure">&quot;<em>ensure</em>&quot;</a> is usefull such a success or unknown case,
      or when you want to execute always.
    </p>
    <p>
     <a href="#reference.function.Pot.isError">isError (Pot.isError)</a> function checks whether argument is an Error object.
    </p>
    <p>
     <a href="#reference.function.Pot.Deferred.prototype.then">&quot;then&quot;</a>, <a href="#reference.function.Pot.Deferred.prototype.rescue">&quot;rescue&quot;</a> and <a href="#reference.function.Pot.Deferred.prototype.ensure">&quot;ensure&quot;</a> each use the same.
     <br>
     Returned value will use for the next callback function's argument.
    </p>
    <p>
     If returned value is an instance of the <a href="#reference.function.Pot.Deferred">Pot.Deferred</a> 
       then last callback chain's returned value passed to the next callback function argument.
    </p>
    <pre>begin(function() {
    return begin(function() {
        return 'ho';
    }).then(function(res) {
        var d = new Deferred();
        return d.then(function() {
            return res + 'ge';
        }).begin();
    });
}).then(function(res) {
    alert(res);
});</pre>
    <p>
     This example will alert 'hoge'.
    </p>
    <p>
     You can nested chain when returned value is an instance of  Pot.Deferred.
    </p>
   </div>
   <h3 id="manualsub.Deferred.Reference.Destructuring-Assignment" class="potjs-manual-item-for-in-view">Destructuring-Assignment</h3>
   <div class="potjs-manual-item-for-in-view">
    <p>
     Pot.Deferred's callback chain can Destructuring-Assignment like.
    </p>
    <pre>begin(function() {
    // Return as Array
    return [1, 2, 3];

// Match the number of arguments and number of items in an array of results.
}).then(function(a, b, c) {

    debug(a); // 1
    debug(b); // 2
    debug(c); // 3

    return [c, b, a]; // Returns a reverse order

}).then(function(a, b, c) {
    // Be reversed and

    debug(a); // 3
    debug(b); // 2
    debug(c); // 1

    return [c, b, a];

}).then(function(res) { // As usual, gets one argument variable.
    // If you specify one argument variable Destructuring-Assignment will not execute.

    debug(res); // [1, 2, 3]

});</pre>
    <p><br></p>
   </div>
   <h3 id="manualsub.Deferred.Reference.speedControl" class="potjs-manual-item-for-in-view">Speed Control</h3>
   <div class="potjs-manual-item-for-in-view">
    <p>
     Pot.Deferred can control the execution speed of callback chain.
    </p>
    <pre>var d = new Deferred();
// Speed down
d<a href="#reference.function.Pot.Deferred.prototype.speed">.speed</a>('slow');

d.then(function() {
    console.log(1);
}).then(function() {
    console.log(2);
}).then(function() {
    console.log(3);
}).begin();</pre>
    <p>
     By doing this, each callback is executed slowly.
     <br>
     This example will display slowly '1', '2' and '3' by console.log().
    </p>
    <p>
     You can specify speed by the 'speed' method.
     You can specify speed by the 'speed' method with String or Number (ms) argument value.
     Refer constant string value following table.
    </p>
    <div>
     <table class="grid" id="manualsub.Deferred.Reference.controlSpeedMap">
      <tr>
       <td class="marker row-head"><strong>value / method name</strong></td>
       <td class="marker row-head"><strong>speed</strong></td>
      </tr>
      <tr>
       <td>limp</td>
       <td>most slowly</td>
      </tr>
      <tr>
       <td>doze</td>
       <td>more slowly</td>
      </tr>
      <tr>
       <td>slow</td>
       <td>slowly</td>
      </tr>
      <tr>
       <td>normal</td>
       <td>normal</td>
      </tr>
      <tr>
       <td>fast</td>
       <td>fast</td>
      </tr>
      <tr>
       <td>rapid</td>
       <td>faster</td>
      </tr>
      <tr>
       <td>ninja</td>
       <td>fastest</td>
      </tr>
     </table>
    </div>
    <p>
     Alternatively, you can pass an argument to the constructor as an option.
    </p>
    <pre>var d = new Deferred({ speed : 'slow' });</pre>
    <p>
     It is also possible to change the speed in the middle of the callback chain.
    </p>
    <pre>var d = new Deferred();
d.then(function() {
    console.log(1);
}).speed('slow').then(function() {
    console.log(2);
    return 2 + 1;
}).speed(5000).then(function(res) {
    console.log(res); // 3
}).begin();</pre>
    <p>
     As in the example above, chain can taking over the value of the result
      and passes to the next callback if the method not needs callback function.
     <br>
     Therefore, the value of the following arguments to pass to the callback
      even if you used <a href="#reference.function.Pot.Deferred.prototype.speed">speed()</a>, <a href="#reference.function.Pot.Deferred.prototype.wait">wait()</a> etc. will not be lost the value.
    </p>
    <p>
     If you want to handle some heavy processing to split, you can reduce the load by specifying the speed.
    </p>
    <pre>begin(function() {
    return someHeavyProcess();
}).speed('slow').then(function(res) {
    return moreHeavyProcess(res);
}).speed('doze').then(function(res) {
    return mostHeavyProcess(res);
}).speed('normal').then(function(res) {
    alert(res);
});</pre>
    <p>
     It is also possible to put a wait in the middle.
    </p>
    <pre>begin(function() {
    return someHeavyProcess();
}).speed('slow').wait(1).then(function(res) {
    return moreHeavyProcess(res);
}).speed('doze').wait(2).then(function(res) {
    return mostHeavyProcess(res);
}).speed('normal').then(function(res) {
    alert(res);
});</pre>
    <p>
     <a href="#reference.function.Pot.Deferred.prototype.wait">wait()</a> is treats argument as the number of seconds.
     Note that because it is not in milliseconds.
    </p>
   </div>
   <h3 id="manualsub.Deferred.Reference.fireChain" class="potjs-manual-item-for-in-view">Fire Chain</h3>
   <div class="potjs-manual-item-for-in-view">
    <p>
     Pot.Deferred's chain can start by <a href="#reference.function.Pot.Deferred.prototype.begin">.begin()</a> method.
    </p>
    <p>
     <a href="#reference.function.Pot.Deferred.begin">begin (Pot.Deferred.begin)</a> as a function is a shortcut
      to create an instance of Pot.Deferred, to start the chain.
     <br>
     Note that <a href="#reference.function.Pot.Deferred.begin">Pot.Deferred.begin()</a> and <a href="#reference.function.Pot.Deferred.prototype.begin">Pot.Deferred.prototype.begin()</a> are different.
    </p>
    <pre>var d = new Deferred();
d.then(function() {
    alert('hoge');
});</pre>
    <p>
     This example never alert 'hoge'.
     <br>
     Just registered a callback to variable 'd' simply.
    </p>
    <p>
     If you add code like the following, will be started the callback chain.
    </p>
    <pre>d.begin();</pre>
    <p>
     You can also set the value of an argument.
    </p>
    <pre>var d = new Deferred();
d.then(function(value) {
    alert(value);
}).begin('hoge');</pre>
    <p>
     In this example, will be alert 'hoge'.
    </p>
    <p>
     The argument value can be passed as the next (in this case, first) callback's arguments.
    </p>
    <p>
     You can start with the <a href="#reference.function.Pot.Deferred.prototype.raise">.raise()</a> method
      instead of the <a href="#reference.function.Pot.Deferred.prototype.begin">.begin()</a> method
      if you want to treat any error by the situation.
    </p>
    <pre>var d = new Deferred();
d.then(function() {
    // On success.
    successFunc();
}).rescue(function() {
    // On error.
    errorFunc();
}).ensure(function() {
    // Final processing.
    finallyFunc();
});

// Validate and succeed if passes the check.
if (check()) {
    d.begin();
} else {
    // Raise a error.
    d.raise();
}</pre>
    <p>
     You can start the callback chain with an error.
     <br>
     Since starting from the error,
      if there is a <a href="#reference.function.Pot.Deferred.prototype.then">.then()</a>
      the first callback will be ignored.
    </p>
    <p>
     The <a href="#reference.function.Pot.Deferred.prototype.raise">.raise()</a>'s argument value can be passed like <a href="#reference.function.Pot.Deferred.prototype.begin">.begin()</a> as the next callback's arguments.
    </p>
   </div>
   <h3 id="manualsub.Deferred.Reference.replaceToDeferred" class="potjs-manual-item-for-in-view">Deferrize function</h3>
   <div class="potjs-manual-item-for-in-view">
    <p>
     Some program might be need deferrize (i.e. convert to Deferred) to the function.
     <br>
     Deferrize is convert to the function to be returned as an instance of  the Pot.Deferred.
    </p>
    <p>
     The following example processes the asynchronous using XMLHttpRequest.
    </p>
    <pre>function request(url, options) {
    var deferred = new Deferred();
    var xhr = new XMLHttpRequest();
    if (options.queryString) {
        url += options.queryString;
    }
    xhr.open(options.method, url, true);
    xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
            if (xhr.status == 200) {
                deferred.begin(xhr);
            } else {
                deferred.raise(xhr);
            }
        }
    };
    deferred.canceller(function() {
        xhr.abort();
    });
    xhr.send(options.sendContent || null);
    return deferred;
}</pre>
    <p>
     This 'request' function simple version that works like <a href="#reference.function.Pot.Net.request">Pot.request()</a> function.
    </p>
    <p>
     Deferrized function must be returned an instance of Deferred.
    </p>
    <p>
     Call the <a href="#reference.function.Pot.Deferred.prototype.begin">.begin()</a> if request succeed.
     And, call <a href="#reference.function.Pot.Deferred.prototype.raise">.raise()</a> if request failed.
     <br>
     When you define a function, will be a more appropriate process, by explicit error handling.
    </p>
    <p>
     <a href="#reference.function.Pot.Deferred.prototype.canceller">&quot;canceller()&quot;</a> method can register callback function that will called when cancelled chain.
     <br>
     You can cancel the chain like below.
    </p>
    <pre>deferred.cancel();</pre>
    <p>
     <a href="#reference.function.Pot.Deferred.prototype.canceller">&quot;canceller()&quot;</a> is possible register one or more callbacks by stackable handling.
    </p>
    <p><br></p>
    <p>
     There's another way of Deferred conversion function.
     <br>
     A function named <a href="#reference.function.Pot.Deferred.deferrize">deferrize (Pot.Deferred.deferrize)</a> is defined in Pot.js / PotLite.js.
    </p>
    <pre>// deferrize window.setTimeout.
var timer = <strong>deferrize</strong>(window, 'setTimeout');

// arguments same as setTimeout usage.
timer(function() {
    debug(1);
}, 5000).then(function() {
    debug(2);
});</pre>
    <p>
     The above example, Deferrize a setTimeout, and run it.
    </p>
    <p>
     This result, wait 5 seconds, the output is in the order of 1, 2 on the console by the function <a href="#reference.function.Pot.debug">debug</a>.
    <p>
     If target function takes a callback, then <a href="#reference.function.Pot.Deferred.deferrize">&quot;deferrize()&quot;</a> will start the Deferred when finished its processing.
     If target function needless the callback, <a href="#reference.function.Pot.Deferred.deferrize">&quot;deferrize()&quot;</a> will be start the Deferred when finished all of processes.
     Starts with <a href="#reference.function.Pot.Deferred.prototype.raise">.raise()</a> if an error occured.
     <br>
     Therefore, most functions can be convert to Deferred by <a href="#reference.function.Pot.Deferred.deferrize">deferrize()</a>.
    </p>
    <p>
     You can deferrize more complex function by your own code using <a href="#reference.Pot.Deferred.methods">Pot.Deferred object functions</a>.
    </p>
   </div>
   <h3 id="manualsub.Deferred.Reference.iterator" class="potjs-manual-item-for-in-view">Iterator</h3>
   <div class="potjs-manual-item-for-in-view">
    <p>
     Pot.js implemented focusing on the asynchronous loop and iteration with <a href="#reference.Pot.Deferred.methods">Pot.Deferred</a>.
    </p>
    <p>
     We are strongly respecting an overview of the JSDeferred.
    </p>
    <p>
     via <a href="http://cho45.stfuawsc.com/jsdeferred/doc/intro.en.html"
            title="Introduction to JSDeferred">Introduction to JSDeferred</a>:
    </p>
    <blockquote>
     <p>
       <strong style="font-size: 120%;">&quot;Speeding Up&quot; JavaScript</strong>
     </p>
     <p>
       When you say &quot;Speed Up&quot; JavaScript,
       it is very important to reduce user's stress rather than speeding up of the process.
     </p>
     <p>
       No matter how fast the process is,
       if it blocks the UI thread for a long time it gives a big stress to the user.
       In JavaScript, <strong>shortest blocking time of UI thread</strong>
       is more important than the overall time of execution.
     </p>
    </blockquote>
    <p>
     Also nested loop will be heavy and the infinity loop might be crashes the browser.
    </p>
    <p>
     Therefore, We implemented the asynchronous
      iterators (<a href="#reference.function.Pot.forEach">forEach</a>, <a href="#reference.function.Pot.map">map</a>, <a href="#reference.function.Pot.reduce">reduce</a>, <a href="#reference.function.Pot.filter">filter</a>, <a href="#reference.function.Pot.some">some</a>, <a href="#reference.function.Pot.every">every</a>, <a href="#reference.function.Pot.repeat">repeat</a>, <a href="#reference.function.Pot.forEver">forEver</a> etc.)
      with <a href="#reference.Pot.Deferred.methods">Pot.Deferred</a>.
     <br>
     Asynchronous iterator calculates the heavy processing of each loop automatically
      and optimizes the process to execute without burdening the CPU.
     <br>
     And we have with the goal to reduce further stress to the UI.
    </p>
    <p>
     All iterators can execute asynchronous and synchronous.
     And its can execute on Deferred chain.
    </p>
    <p>
     Example JavaScript for-in:
    </p>
    <pre>for (var key in object) {...}</pre>
    <p>
     Case of <a href="#reference.function.Pot.forEach">Pot.forEach</a> (synchronous):
    </p>
    <pre>forEach(object, function(value, key) {...});</pre>
    <p>
     Case of <a href="#reference.function.Pot.forEach">Pot.Deferred.forEach</a> (asynchronous):
    </p>
    <pre>Deferred.forEach(object, function(value, key) {...});</pre>
    <p>
     Asynchronous iterator returns an instance of Pot.Deferred.
     <br>
     If Pot.globalize()d, you can call '<em>Pot.Deferred.forEach</em>' as '<em>Deferred.forEach</em>'.
    </p>
    <p>
     Case of execute on Deferred chain:
    </p>
    <pre>(new Pot.Deferred()).forEach(function(value, key) {...}).begin( object );</pre>
    <p>
     If you execute loop to the array that has 10,000 or more items,
      about burdening to the CPU will be great difference between
      Pot.js asynchronous iterator (e.g. Pot.Deferred.forEach)
      and JavaScript loop (for-in, while etc.).
     <br>
     Also, you can avoid &quot;Unresponsive script&quot; alert on the Web browser by using Pot.js asynchronous iterator.
    </p>
    <p>
     All related to the Pot.js asynchronous iterator, you can adjust the speed.
     <br>
     If you want to run slowly, like as follows:
    </p>
    <pre>Deferred.forEach.slow(obj, function() {...});</pre>
    <p>
     If you want to run fast, like as follows:
    </p>
    <pre>Deferred.forEach.fast(obj, function() {...});</pre>
    <p>
     Refer <a href="#manualsub.Deferred.Reference.controlSpeedMap">speed value table</a> if you want to use other speed.
    </p>
    <p>
     Also it is might be the frequent load and freeze by burdening process on web browser not only time-consuming loop.
     <br>
     Such handle also, you can be fixed by cutback processing and run without burdening the CPU.
    </p>
    <p>
     When handling a large amount of DOM elements, for example:
    </p>
    <pre>// Suppose the HTML page that is larger and it has many elements.
var elems = document.getElementsByTagName('*');</pre>
    <p>
     The conventional synchronization loop will not be give a rest for thread till end of loop.
    </p>
    <pre>var len = elems.length;
for (var i = 0; i &lt; len; i++) {
    var elem = elems[i];
    someHeavyProcess(elem); // Some heavy processing function.
}</pre>
    <p>
     This example code will crazy loops even if web browser is freezed.
    </p>
    <p>
     You can write loop with the Pot.Deferred object.
    </p>
    <pre>Deferred.repeat(elems.length, function(i) {
    var elem = elems[i];
    someHeavyProcess(elem); // Some heavy processing function.
});</pre>
    <p>
     Most load will be reduced by this refactoring.
     Pot.js's iterator calculate the load of processing for each loop.
     If CPU utilization is over to some extent,
      will be returned control to the web browser,
      and then adjusted so as not to monopolize the thread.
    </p>
    <p>
     Also, you can use <a href="#reference.function.Pot.forEach">forEach</a> method.
    </p>
    <pre>Deferred.forEach(elems, function(elem) {
    someHeavyProcess(elem); // Some heavy processing function.
});</pre>
    <p>
     If someHeavyProcess() is able to divide to some callbacks, you can write other way.
    </p>
    <pre>Deferred.forEach(elems, function(elem) {
    return begin(function() {
        someHeavyProcess1(elem);
    }).wait(1).then(function() {
        someHeavyProcess2(elem);
    }).wait(1).then(function() {
        someHeavyProcess3(elem);
    });
});</pre>
    <p>
     Split the processing of cases like this,
      you can connected with a method such as the chain <a href="#reference.function.Pot.Deferred.prototype.wait">.wait()</a> etc.
    </p>
    <p>
     Note:
     <br>
     <a href="#reference.function.Pot.Deferred.begin">begin()</a> will be returned an instance of the Pot.Deferred.
     Callback function should has a return statement
      if you want to run asynchronous processing in the asynchronous iterator (e.g. Pot.Deferred.forEach)
      for consistent of each iteration.
    </p>
    <p>
     If load balancing is still necessary,
      you can eliminate by specifying the speed of slow (refer <a href="#manualsub.Deferred.Reference.controlSpeedMap">speed control table's value</a>).
    </p>
    <pre>Deferred.forEach.<strong>slow</strong>(elems, function(elem) {
    someHeavyProcess(elem);
});</pre>
    <p>
     All of Pot.js's asynchronous iterator can control to speed.
     (e.g. 'forEach.rapid(function() {...})').
    </p>
   </div>
   <h3 id="manualsub.Deferred.Reference.replaceLoop" class="potjs-manual-item-for-in-view">Optimize loop</h3>
   <div class="potjs-manual-item-for-in-view">
    
    
    <h1 class="error">途中...<br>The translation is still going on...</h1>
    
    
    <p>
     既存のループで負荷がかかっている処理を、
     Pot.js のイテレータを用いて軽減させることができます。
    </p>
    <pre>function someLoop(n, c) {
    var results = [];
    for (var i = 0; i &lt; n; i++) {
        var array = [];
        for (var j = 0; j &lt; c; j++) {
            array[j] = j;
        }
        results[i] = array;
    }
    return results;
}</pre>
    <p>
     例えばこのような関数があったとします。
     <br>
     引数 c 回ループした配列を引数 n 個分持つ配列を返す関数です。
    </p>
    <p>
     例えばこれを、
    </p>
    <pre>var array = someLoop(100000, 1000);</pre>
    <p>
     このような大きい配列を作るとなると、
     スペックにもよりますが、
     瞬間的な負荷は大きくなり UI を独占してしまうでしょう。
    </p>
    <p>
     この関数を Deferred 化してみます。
    </p>
    <pre>function someLoopDefer(n, c) {
    var results = [];
    return Deferred.repeat(n, function(i) {
        var array = [];
        for (var j = 0; j &lt; c; j++) {
            array[j] = j;
        }
        results[i] = array;
    }).then(function() {
        return results;
    });
}</pre>
    <p>
     例として、このようになります。
     <br>
     内側の for はこのままでいいのかと思うかもしれませんが、
     おそらく repeat、Deferred.repeat 等に変えたところで
     必要以上に負荷が分散され、結果としてかなり速度は落ちてしまうでしょう。
     <br>
     なので、いちばん外側のループのみを置き換えます。
     <br>
     もっとも、この例の場合は
     内側の for を何度も実行する必要はありませんが、
     あくまで例として捉えてください。
     <br>
     返り値は Deferred になります。
    </p>
    <pre>someLoopDefer(100000, 1000).then(function(res) {
    var array = res;
});</pre>
    <p>
     Deferred が返るので、then などで結果を取得します。
     そのままチェインを繋げることもできます。
    </p>
    <p>
     この変化により、瞬間的な処理の重さが分散され
     安定した処理が可能となります。
     <br>
     そのかわり、処理時間は若干伸びる可能性があります。
    </p>
    <p>
     Pot.Deferred のイテレータを使う場合、
     このように
     あまり意識せずに分散的なループが可能となります。
    </p>
   </div>
   <h3 id="manualsub.Deferred.Reference.StopIteration" class="potjs-manual-item-for-in-view">イテレートを止める</h3>
   <div class="potjs-manual-item-for-in-view">
    <p>
     Pot.js, PotLite.js で実装されている
     すべてのイテレータは、
     <br>
     StopIteration を throw することで中断できます。
    </p>
    <pre>var foo = '';
forEver(function(i) {
    foo += 'foo';
    if (foo.length &gt; 10) {
        throw StopIteration;
    }
});

debug(foo);</pre>
    <p>
     この例は、debug 関数により
     コンソールに 'foofoofoofoo' と出力されます。
    </p>
    <p>
     forEver (Pot.forEver) は、StopIteration が throw されるまで
     永遠にループします。
     <br>
     複雑な条件式でループを制御する場合や、
     そのような既存の重い処理を
     Deferred.forEver で置き換えたい場合などに活用できます。
    </p>
    <p>
     StopIteration は、 Array.prototype.forEach が有効な環境など、
     コンフリクトする可能性があるときは
     Pot.StopIteration と明示することで解消できます。
    </p>
    <p>
     StopIteration を判別する方法は、
    </p>
    <pre>if (isStopIter(e)) {...}</pre>
    <p>
     または、
    </p>
    <pre>if (e == StopIteration) {...}</pre>
    <p>
     と単純に比較か、
    </p>
    <pre>if (e instanceof StopIteration) {...}</pre>
    <p>
     とすることもできます。
    </p>
    <p>
     おそらく Pot.js ライブラリが実装している
     isStopIter (Pot.isStopIter) が確実です。
    </p>
    <p><br></p>
    <p>
     実装されているすべてのイテレータは、
     コールバック関数が非同期の Deferred オブジェクトを
     いくつにもネストしたとしても、
     <br>
     throw StopIteration によりスコープ間を超えて
     実行中のイテレータ関数のスコープまで届くよう設計されています。
    </p>
    <pre>var result = [];
begin(function() {
    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
}).forEach(function(value) {
    return begin(function() {
        var d = new Deferred();
        return d.then(function() {
            if (value &gt; 5) {

                // 実行しているイテレータのスコープが対象になるため
                // この例では いちばん外側の .forEach まで届く

                throw StopIteration;
            }
            return value * 100;
        }).begin();
    }).then(function(res) {
        result.push(res);
    });
}).then(function() {
    debug(result);
    //  =&gt;  [100, 200, 300, 400, 500]
});</pre>
   </div>
 </div>
</div>


<!--}}}:#Pot.js-reference-content-->
</div>
</body>
</html>