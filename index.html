<!DOCTYPE html>
<html lang="ja" dir="ltr">
<head>
<meta charset="UTF-8">
<title>Pot.js + PotLite.js - ドキュメントリファレンス - JavaScript非同期処理ライブラリ</title>
<link rel="shourtcut icon" href="http://api.polygonpla.net/img/favicon/potjs-favicon.ico">
<meta name="description" lang="en" content="Pot.js/PotLite.js - JavaScript utility library for asynchronous processing with Deferred.">
<meta name="keywords" lang="en" content="pot,potlite,potjs,pot.js,potlite.js,javascript,asynchronous,async,deferred,defer,deferrize,iterator,iterate,ecmascript,node.js,cross-browser,ajax,xmlhttprequest,json,jsonp,library">
<meta name="description" lang="ja" content="Pot.js/PotLite.jsは,非ブロックでの非同期処理を直列的に書けるようにし,UIやCPUへの負担を軽減するループ処理を中心にDeferredと共に実装されたJavaScriptライブラリ.">
<meta name="keywords" lang="ja" content="pot,potlite,potjs,pot.js,potlite.js,javascript,asynchronous,async,非同期,並列,同期,負荷,分散,deferred,defer,deferrize,iterator,iterate,イテレータ,ecmascript,node.js,cross-browser,クロスブラウザ,ajax,xmlhttprequest,json,jsonp,library,ライブラリ">
<link rel="Pot.js Repository - GitHub" href="http://github.com/polygonplanet/Pot.js">
<link rel="Pot.js Develop Blog" href="http://polygon-planet.blogspot.com/2011/10/javascriptdeferred.html">
<link rel="author" title="polygon planet" href="http://polygonpla.net/">
<link rel="stylesheet" type="text/css" href="http://api.polygonpla.net/css/pot.css">
<style>
/*
html, body {
  color: #555;
  background: #f8f8ff;
}
*/

dl dd {
  margin-bottom: 1em;
}

dfn em {
  font-weight: normal;
  color: #666;
}

td.header, td.header * {
  font-weight: bold;
}

td.marker, td.marker * {
  background: #e2e5ff;
}

.header-logo {
  width: 350px;
  height: 165px;
  background-color: transparent;
  margin: 5px 5px 5px 25px;
}

#top {
  font-size: 120%;
  display: inline;
}


body .toggle-trigger {
  margin: 2px;
  padding: 0 2px 0 2px;
  width: 11px;
  min-width: 10px;
  height: 14px;
  color: #555;
  background: #fafaff;
  border: 1px solid #555;
  font-size: 11px;
  font-family: verdana, sans-serif;
  font-weight: normal;
  line-height: 1.2;
  border-radius: 3px;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  text-align: center;
  vertical-align: middle;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
  user-select: none;
  cursor: pointer;
  display: inline-block;
  *display: inline;
  *zoom: 1;
}

</style>
<!--[if lt IE 7]>
<script>var IE7_PNG_SUFFIX = '.png';</script>
<script src="http://ie7-js.googlecode.com/svn/version/2.1(beta4)/IE7.js"></script>
<![endif]-->
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.6.4/jquery.min.js"></script>
<script type="text/javascript">
$(function() {

  $('.toggle-trigger-pre')
    .removeClass('toggle-trigger-pre')
    .addClass('toggle-trigger')
    .addClass('toggle-shown')
    .click(function() {
      var block = $(this).next().next('ul');
      if ($(this).hasClass('toggle-shown')) {
        $(this).removeClass('toggle-shown').text('+');
        block.hide();
      } else {
        $(this).addClass('toggle-shown').text('-');
        block.show();
      }
    })
    .click()
    .parent('li')
      .css({
        listStyleType : 'none'
      })
      .parent('ul')
        .css({
          marginLeft : 10
        });
  
});
</script>
<script type="text/javascript" src="http://api.polygonpla.net/js/google/analytics.js?ua=UA-16159469-28"></script>
</head>
<body id="doc">
  <div class="layout-liquid-container">
    <div class="header">
      <div class="header-logo">
       <a href="http://polygonplanet.github.com/Pot.js/index.html"
          title="Pot.js + PotLite.js - ドキュメントリファレンス - JavaScript非同期処理ライブラリ"><img src="http://api.polygonpla.net/img/logo/potlite.js.mini.png"></a>
      </div>
      <h1 id="top">Pot.js</h1>
      <p>
       JavaScript utility library for asynchronous processing with Deferred.
      </p>
      <div style="width: 100%; text-align: center;"><hr></div>
    </div>
    <div class="clearfix">
      <div class="content">
        <div class="leftside">
          <h2 id="index">目次</h2>
          <ul>
            <li><a href="#overview">概要</a></li>
            <li><a href="#download">ダウンロード</a></li>
            <li><a href="#install">インストール</a></li>
            <li><a href="#compatibility">動作環境</a></li>
            <li><a href="#TestRun">動作テスト</a></li>
            <li><a href="#license">ライセンス</a></li>
            <li><a href="#contact">連絡先</a></li>
            <li><a href="#thanks">謝辞</a></li>
            <li><a href="#forJSDoc">自動生成されたドキュメント</a></li>
            <li><a href="#introduction">導入</a></li>
            <li>
              <a href="#reference">リファレンス</a>
              <ul>
                <li><a href="#callbackChain">チェイン</a></li>
                <li><a href="#exception">例外処理</a></li>
                <li><a href="#Destructuring-Assignment">分割代入</a></li>
                <li><a href="#controlSpeed">速度の操作</a></li>
                <li><a href="#fireChain">チェインを実行</a></li>
                <li><a href="#replaceToDeferred">関数を Deferred 化</a></li>
                <li><a href="#iterator">イテレータ</a></li>
                <li><a href="#replaceLoop">ループ処理を置き換える</a></li>
                <li><a href="#StopIteration">イテレートを止める</a></li>
                <li>
                  <a href="#referenceFunctions">関数リファレンス</a>
                  <ul>
                    <li>
                      <span class="toggle-trigger-pre"></span>
                      <a href="#PotObjectFunctions">Pot オブジェクトの関数</a>
                      <ul>
                        <li><a href="#function.Pot.update">update</a></li>
                        <li><a href="#function.Pot.stringify">stringify</a></li>
                        <li><a href="#function.Pot.arrayize">arrayize</a></li>
                        <li><a href="#function.Pot.rescape">rescape</a></li>
                        <li><a href="#function.Pot.trim">trim</a></li>
                        <li><a href="#function.Pot.now">now</a></li>
                        <li><a href="#function.Pot.debug">debug</a></li>
                        <li><a href="#function.Pot.isBoolean">isBoolean</a></li>
                        <li><a href="#function.Pot.isNumber">isNumber</a></li>
                        <li><a href="#function.Pot.isString">isString</a></li>
                        <li><a href="#function.Pot.isFunction">isFunction</a></li>
                        <li><a href="#function.Pot.isArray">isArray</a></li>
                        <li><a href="#function.Pot.isDate">isDate</a></li>
                        <li><a href="#function.Pot.isRegExp">isRegExp</a></li>
                        <li><a href="#function.Pot.isObject">isObject</a></li>
                        <li><a href="#function.Pot.isError">isError</a></li>
                        <li><a href="#function.Pot.typeOf">typeOf</a></li>
                        <li><a href="#function.Pot.isStopIter">isStopIter</a></li>
                        <li><a href="#function.Pot.isIterable">isIterable</a></li>
                        <li><a href="#function.Pot.isArrayLike">isArrayLike</a></li>
                        <li><a href="#function.Pot.isDeferred">isDeferred</a></li>
                        <li><a href="#function.Pot.isIter">isIter</a></li>
                        <li><a href="#function.Pot.isNumeric">isNumeric</a></li>
                        <li><a href="#function.Pot.isInt">isInt</a></li>
                        <li><a href="#function.Pot.isBuiltinMethod">isBuiltinMethod</a></li>
                        <li><a href="#function.Pot.isWindow">isWindow</a></li>
                        <li><a href="#function.Pot.isDocument">isDocument</a></li>
                        <li><a href="#function.Pot.isElement">isElement</a></li>
                        <li><a href="#function.Pot.isNodeList">isNodeList</a></li>
                        <li><a href="#function.Pot.isNodeLike">isNodeLike</a></li>
                        <li><a href="#function.Pot.range">range</a></li>
                        <li><a href="#function.Pot.indexOf">indexOf</a></li>
                        <li><a href="#function.Pot.lastIndexOf">lastIndexOf</a></li>
                        <li><a href="#function.Pot.request">request</a></li>
                        <li><a href="#function.Pot.jsonp">jsonp</a></li>
                        <li><a href="#function.Pot.loadScript">loadScript</a></li>
                        <li><a href="#function.Pot.serializeToJSON">serializeToJSON</a></li>
                        <li><a href="#function.Pot.parseFromJSON">parseFromJSON</a></li>
                        <li><a href="#function.Pot.serializeToQueryString">serializeToQueryString</a></li>
                        <li><a href="#function.Pot.parseFromQueryString">parseFromQueryString</a></li>
                        <li><a href="#function.Pot.urlEncode">urlEncode</a></li>
                        <li><a href="#function.Pot.urlDecode">urlDecode</a></li>
                      </ul>
                    </li>
                    <li>
                      <span class="toggle-trigger-pre"></span>
                      <a href="#iteratorFunctions">イテレータ関数</a>
                      <ul>
                        <li><a href="#function.Pot.forEach">forEach</a></li>
                        <li><a href="#function.Pot.repeat">repeat</a></li>
                        <li><a href="#function.Pot.forEver">forEver</a></li>
                        <li><a href="#function.Pot.iterate">iterate</a></li>
                        <li><a href="#function.Pot.Iter">Iter</a></li>
                        <li><a href="#function.Pot.toIter">toIter</a></li>
                        <li><a href="#function.Pot.items">items</a></li>
                        <li><a href="#function.Pot.zip">zip</a></li>
                        <li><a href="#function.Pot.map">map</a></li>
                        <li><a href="#function.Pot.filter">filter</a></li>
                        <li><a href="#function.Pot.reduce">reduce</a></li>
                        <li><a href="#function.Pot.every">every</a></li>
                        <li><a href="#function.Pot.some">some</a></li>
                      </ul>
                    </li>
                    <li>
                      <span class="toggle-trigger-pre"></span>
                      <a href="#PotDeferredMethods">Pot.Deferred のメソッド</a>
                      <ul>
                        <li><a href="#function.Pot.Deferred">Deferred</a></li>
                        <li><a href="#function.Pot.Deferred.prototype.then">then</a></li>
                        <li><a href="#function.Pot.Deferred.prototype.rescue">rescue</a></li>
                        <li><a href="#function.Pot.Deferred.prototype.ensure">ensure</a></li>
                        <li><a href="#function.Pot.Deferred.prototype.begin">begin</a></li>
                        <li><a href="#function.Pot.Deferred.prototype.raise">raise</a></li>
                        <li><a href="#function.Pot.Deferred.prototype.end">end</a></li>
                        <li><a href="#function.Pot.Deferred.prototype.wait">wait</a></li>
                        <li><a href="#function.Pot.Deferred.prototype.till">till</a></li>
                        <li><a href="#function.Pot.Deferred.prototype.cancel">cancel</a></li>
                        <li><a href="#function.Pot.Deferred.prototype.canceller">canceller</a></li>
                        <li><a href="#function.Pot.Deferred.prototype.speed">speed</a></li>
                        <li><a href="#function.Pot.Deferred.prototype.async">async</a></li>
                        <li><a href="#function.Pot.Deferred.prototype.args">args</a></li>
                        <li><a href="#function.Pot.Deferred.prototype.data">data</a></li>
                      </ul>
                    </li>
                    <li>
                      <span class="toggle-trigger-pre"></span>
                      <a href="#PotDeferredFunctions">Pot.Deferred の関数</a>
                      <ul>
                        <li><a href="#function.Pot.Deferred.succeed">succeed</a></li>
                        <li><a href="#function.Pot.Deferred.failure">failure</a></li>
                        <li><a href="#function.Pot.Deferred.wait">wait</a></li>
                        <li><a href="#function.Pot.Deferred.till">till</a></li>
                        <li><a href="#function.Pot.Deferred.begin">begin</a></li>
                        <li><a href="#function.Pot.Deferred.flush">flush</a></li>
                        <li><a href="#function.Pot.Deferred.maybeDeferred">maybeDeferred</a></li>
                        <li><a href="#function.Pot.Deferred.callLater">callLater</a></li>
                        <li><a href="#function.Pot.Deferred.callLazy">callLazy</a></li>
                        <li><a href="#function.Pot.Deferred.isFired">isFired</a></li>
                        <li><a href="#function.Pot.Deferred.lastResult">lastResult</a></li>
                        <li><a href="#function.Pot.Deferred.lastError">lastError</a></li>
                        <li><a href="#function.Pot.Deferred.register">register</a></li>
                        <li><a href="#function.Pot.Deferred.unregister">unregister</a></li>
                        <li><a href="#function.Pot.Deferred.deferrize">deferrize</a></li>
                        <li><a href="#function.Pot.Deferred.parallel">parallel</a></li>
                        <li><a href="#function.Pot.Deferred.chain">chain</a></li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </div>
        <div style="width: 100%; text-align: center"><hr></div>
        <h2 id="overview">概要</h2>
        <p>
         非ブロックでの非同期処理を直列的に書けるようにし、
         <br>
         UI や CPU への負担を軽減するループ処理を中心に実装された JavaScript ライブラリです。
         <br>
         MochiKit ライクな Deferred オブジェクトにより
         <br>
         様々なイテレート (forEach, filter, map, repeat, some など) を可能とします。
        </p>
        <h2 id="download">ダウンロード</h2>
        <div>
         <div style="margin: 8px;">
           <div>
            <h4>最新</h4>
           </div>
           <ul>
             <li><a href="http://github.com/polygonplanet/Pot.js/zipball/master"
                    title="最新のzip"><strong>zip</strong></a>
             </li>
             <li><a href="http://github.com/polygonplanet/Pot.js/tarball/master"
                    title="最新のtar.gz"><strong>tar</strong></a>
             </li>
           </ul>
         </div>
         <div style="margin: 8px;">
           <div>
            <h4>Pot.js</h4>
           </div>
           <ul>
             <li>
              (調整中)
             </li>
           </ul>
         </div>
         <div style="margin: 8px;">
           <div>
            <h4>PotLite.js (lite)</h4>
           </div>
           <ul>
             <li><a href="https://github.com/polygonplanet/Pot.js/raw/master/potlite.js"
                    title="Development (Uncompressed Code)"><strong>potlite.js</strong> - Development (Uncompressed Code)</a>
             </li>
             <li><a href="https://github.com/polygonplanet/Pot.js/raw/master/potlite.min.js"
                    title="Production (Minified)"><strong>potlite.min.js</strong> - Production (Minified)</a>
             </li>
           </ul>
         </div>
         <div style="margin: 8px;">
           <div>
            <h4>レポジトリ</h4>
           </div>
           <pre>$ git clone git://github.com/polygonplanet/Pot.js</pre>
           <div style="margin: 8px;">
             <p>
              GitHub : <a href="http://github.com/polygonplanet/Pot.js"
                          title="polygonplanet/Pot.js - GitHub">polygonplanet/Pot.js</a>
             </p>
           </div>
         </div>
        </div>
        <h2 id="install">インストール</h2>
        <div>
         <p>
          一般的な方法で動作します。
         </p>
         <p>
          例:
         </p>
         <pre>&lt;script type="text/javascript" src="potlite.min.js"&gt;&lt;/script&gt;</pre>
         読み込み後の例:
         <pre>&lt;script type="text/javascript"&gt;
// 任意に globalize で短い記述にできる (下記参照)
Pot.globalize();

begin(function() {
    return request('./hoge.json', {
        mimeType : 'text/javascript'
    }).then(function(res) {
        return parseFromJSON(res.responseText);
    });
}).then(function(res) {
    return Deferred.forEach(res.items, function(value, key) {
        // ...
    });
});
// ...
&lt;/script&gt;</pre>
         <p>
          Node.js の場合。
         </p>
         <pre>// Example to define Pot object on Node.js.
var Pot = require('./potlite.js');
Pot.debug(Pot.VERSION);

Pot.Deferred.begin(function() {
    Pot.debug('Hello Deferred!');
}).then(function() {...})
// ...</pre>
         <p>
          Greasemonkey (userscript) の例。
         </p>
         <pre>// ==UserScript==
// ...
// @require  https://github.com/polygonplanet/Pot.js/raw/master/potlite.min.js
// ...
// ==/UserScript==

Pot.Deferred.begin(function() {
    return Pot.request('http://www.example.com/data.json').then(function(res) {
        return Pot.parseFromJSON(res.responseText);
    });
}).then(function(res) {
    Pot.debug(res);
    // do something...
});
//...</pre>
         <p>
          jQuery プラグインとして。
         </p>
         <pre>// jQuery を読み込んだ後に実行。
Pot.deferrizejQueryAjax();

// Ajax 系の関数が Pot.Deferred を返すようになる
$.getJSON('/hoge.json').then(function(data) {
    alert(data.results[0].text);
}).rescue(function(err) {
    alert('Error! ' + err);
}).ensure(function() {
    return someNextProcess();
});

// エフェクトなどを Deferred 化する 'deferred' が追加される
$('div#hoge').deferred('hide', 'slow').then(function() {
    // ( hide() が終了したあとの処理)
});</pre>
         <p>
          Pot.deferrizejQueryAjax() は現状、
          ライブラリ側で実行しません。
          なので、プラグインを使用する場合は
          コードの最初などで実行する必要があります。
         </p>
        </div>
        <h2 id="compatibility">動作環境</h2>
        <div>
         <div>
           <p>以下の Web ブラウザで動作確認済みです。</p>
           <ul>
             <li>Mozilla Firefox *</li>
             <li>Internet Explorer 6+</li>
             <li>Safari *</li>
             <li>Opera *</li>
             <li>Google Chrome *</li>
           </ul>
           <p>また、以下の環境でも動作するよう設計されています。</p>
           <ul>
             <li>Greasemonkey (userscript)</li>
             <li>Mozilla Firefox Add-On (on XUL)</li>
             <li>Node.js</li>
             <li>Other non-browser environment</li>
           </ul>
         </div>
        </div>
        <h2 id="TestRun">動作テスト</h2>
        <div>
         <p>
          以下のページで動作テストができます。
         </p>
         <ul>
          <li>
           <a href="potlite.test.html" title="PotLite.js - Test Run">PotLite.js Test Run</a>
          </li>
         </ul>
        </div>
        <h2 id="license">ライセンス</h2>
        <div>
         <p>
          Dual licensed under the MIT and GPL v2 licenses.
         </p>
         <p>
          Copyright &copy; 2011 polygon planet
         </p>
        </div>
        <h2 id="contact">連絡先</h2>
        <div>
         <p>
          <strong>Author</strong>: polygon planet
         </p>
         <p>
          <a href="http://twitter.com/polygon_planet" title="Twitter @polygon_planet">@polygon_planet</a>
          または (polygon.planet[at]gmail.com) まで、
          <br>
          意見・感想・要望などなんでも送っていただけるとうれしいです。
         </p>
        </div>
        <h2 id="thanks">謝辞</h2>
        <div>
         <p>
          ロゴを作成してくれた
          <a href="http://r-m-t.jp/" title="R M T　|　同人音楽サークル">yinyang302mg</a> さん、
          そして Pot.js / PotLite.js を作る切欠となった
          <a href="http://cho45.stfuawsc.com/jsdeferred/" title="JSDeferred - cho45.stfuawsc.com">JSDeferred</a>
          ,
          <a href="http://www.mochimedia.com/" title="Mochi Media, Inc.">MochiKit (Mochi Media, Inc.)</a>
          ,
          <a href="https://github.com/to/tombloo/wiki" title="Tombloo - Home - GitHub">Tombloo</a>
          developers に感謝いたします。
         </p>
        </div>
        <h2 id="forJSDoc">自動生成されたドキュメント</h2>
        <div>
         <ul>
          <li><a href="jsdoc/potlite/index.html"
                 title="PotLite.js - JsDoc Reference - Index">JSDoc ドキュメント (PotLite.js)</a>
          </li>
         </ul>
         <p>
          <a href="http://code.google.com/intl/ja/closure/compiler/docs/js-for-compiler.html"
             title="Annotating JavaScript for the Closure Compiler - Closure Compiler - Google Code">Closure Compiler</a>
          によりソースコードから自動生成されたドキュメントです。
         </p>
         <p>
          殆どの関数ごとにサンプルコードを載せているので、ある程度は参考になると思います。
          <br>
          生成物をすべて確認しているわけではないので、誤認識してる箇所もあるかもしれません。
          <br>
          より詳細な実装などは直接ソースコードを参照ください。
         </p>
        </div>
        <h2 id="introduction">導入</h2>
        <div>
         <div>
           <p>
            現在、PotLite.js という lite バージョンのみ扱っています。
           </p>
           <p>
            このドキュメントは、PotLite.js について扱います。
           </p>
           <p>
            Pot.js および PotLite.js は、
            他のライブラリと名前などが衝突しないよう
            <br>
            Pot というオブジェクトのみグローバルに定義されます。
            <br>
            Node.js などモジュールが有効な環境では、
            グローバルに定義する代わりに exports を使用し
            require によって利用できるよう定義されます。
           </p>
           <p>
            関数名などを短い記述で書きたい場合、
           </p>
           <pre>Pot.globalize();</pre>
           <p>
            と最初に記述することで、
            例えば Pot.Deferred.begin が begin だけの記述で呼び出せるようになります。
            <br>
            もし、他のライブラリ等と名前の衝突してしまう場合は
            無理と短い記述をする必要ありません。
           </p>
           <p>
            また、Pot.globalize() は
           </p>
           <pre>Pot.globalize(object);</pre>
           <p>
            上のように引数に何らかのオブジェクトを与えることで、
            任意のオブジェクトをグローバルスコープに置きたい時に活用できます。
           </p>
         </div>
        </div>
        <h2 id="reference">リファレンス</h2>
        <div>
         <div>
           <p>
            以降、Pot.Deferred について解説します。
           </p>
           <h3 id="callbackChain">チェイン</h3>
           <div>
            <p>
             根本的なことですが、
             Pot.Deferred は JavaScript の非同期処理を直列化できるように作られています。
            </p>
            <pre>setTimeout(function() {
    something1();
    setTimeout(function() {
        something2();
        setTimeout(function() {
            something3();
        }, 0);
    }, 0);
}, 0);</pre>
            <p>
             このように深くなってしまうネストを、
            </p>
            <pre>begin(something1).then(something2).then(something3);</pre>
            <p>
             というふうに書けるようになります。
            </p>
            <p>
             シンプルな非同期処理を Pot.Deferred を使い書いてみます。
            </p>
            <pre>begin(function() {
    console.log('begin');
    return wait(2);
}).then(function() {
    console.log('end');
});</pre>
            <p>
             これは、begin によって非同期で処理が始まり
             コンソールに 'begin' と出力した後、2 秒待ってから 'end' と出力されます。
            </p>
            <p>
             Pot.globalize() の適応がされてない場合は、
            </p>
            <pre>Pot.Deferred.begin(function() {
    console.log('begin');
    return Pot.Deferred.wait(2);
}).then(function() {
    console.log('end');
});</pre>
            <p>
             という記述になります。
            </p>
            <p>
             (以降は便宜上 Pot.globalize() がなされた記述で例を示します。)
            </p>
            <div>
             <p>
              他の Deferred ライブラリの経験がある場合、
              関数名の違いに違和感を感じるかもしれないので以下に示します。
              (いくつか解釈が違うものもあります。)
             </p>
             <div>
               <table class="grid" id="DeferredLibraryMap">
                 <tr>
                   <td class="header marker" style="width: 19%;">
                     <a href="http://polygonplanet.github.com/Pot.js/index.html"
                        title="Pot.js + PotLite.js - ドキュメントリファレンス">Pot.Deferred</a>
                   </td>
                   <td class="header" style="width: 19%;">
                     <a href="http://mochi.github.com/mochikit/doc/html/MochiKit/Async.html#fn-deferred"
                        title="MochiKit.Async - manage asynchronous tasks">MochiKit.Async.Deferred</a>
                   </td>
                   <td class="header" style="width: 19%;">
                     <a href="http://cho45.stfuawsc.com/jsdeferred/"
                        title="JSDeferred - cho45.stfuawsc.com">JSDeferred</a>
                   </td>
                   <td class="header" style="width: 19%;">
                     <a href="http://api.jquery.com/category/deferred-object/"
                        title="Deferred Object -- jQuery API">jQuery.Deferred</a>
                   </td>
                   <td class="header" style="width: 19%;">
                     <a href="http://docs.dojocampus.org/dojo/Deferred"
                        title="dojo/Deferred - DojoCampus - Docs">dojo.Deferred</a>
                   </td>
                 </tr>
                 <tr>
                   <td class="marker">then</td>
                   <td>addCallback(s)</td>
                   <td>next</td>
                   <td>done / then</td>
                   <td>then / addCallback(s)</td>
                 </tr>
                 <tr>
                   <td class="marker">rescue</td>
                   <td>addErrback</td>
                   <td>error</td>
                   <td>fail</td>
                   <td>addErrback</td>
                 </tr>
                 <tr>
                   <td class="marker">ensure</td>
                   <td>addBoth</td>
                   <td>-</td>
                   <td>always</td>
                   <td>addBoth</td>
                 </tr>
                 <tr>
                   <td class="marker">begin</td>
                   <td>callback</td>
                   <td>call</td>
                   <td>resolve</td>
                   <td>resolve / callback</td>
                 </tr>
                 <tr>
                   <td class="marker">raise</td>
                   <td>errback</td>
                   <td>fail</td>
                   <td>reject</td>
                   <td>reject / errback</td>
                 </tr>
                 <tr>
                   <td class="marker">cancel</td>
                   <td>cancel</td>
                   <td>cancel</td>
                   <td>-</td>
                   <td>cancel</td>
                 </tr>
               </table>
             </div>
            </div>
            <p>
             Pot.Deferred は MochiKit.Async.Deferred および JSDeferred とほぼ同じ動作をします。
            </p>
            <p>
             <br>
            </p>
            <p>
             以降の解説に関して、Deferred の基本的なものは
             <a href="http://cho45.stfuawsc.com/jsdeferred/doc/intro.html"
                title="JSDeferred 紹介">JSDeferred のドキュメント</a>
             を参考にしています。
             ゆえに、内容がそっくりになってしまっていますのでご了承ください。
             なお、問題等ありましたら <a href="#contact">連絡先</a> までお願いします。
             JSDeferred の解説はとてもわかりやすいので、Deferred に関して情報を得たい場合、
             一度は閲覧することをお勧めします。
            </p>
            <p>
             非同期処理は、setTimeout だけでなく
             Ajax や onclick などのイベント時にも発生します。
             <br>
             例えば request という関数が、第一引数に URL を、
             第二引数にコールバック関数をとるものとします。
             <br>
             これを Deferred なしで書くと、
            </p>
            <pre>request('/foo.json', function(fooData) {
    request('/bar.json', function(barData) {
        request('/baz.json', function(bazData) {
            alert([fooData.result, barData.result, bazData.result]);
        });
    });
});</pre>
            <p>
             リクエストが増えれば増えるほどネストが深くなってしまいます。
            </p>
            <p>
             これを Pot.Deferred を用いて書くと、
            </p>
            <pre>// request は第一引数に URL をとり Deferred が返る関数として
var result = [];
begin(function() {
    return request('/foo.json').then(function(fooData) {
        result.push(fooData.result);
    });
}).then(function() {
    return request('/bar.json').then(function(barData) {
        result.push(barData.result);
    });
}).then(function() {
    return request('/baz.json').then(function(bazData) {
        result.push(bazData.result);
    });
}).then(function() {
    alert(result);
});</pre>
            <p>
             他にも多様な書き方がありますが、処理が直列的になりました。
            </p>
            <p>
             しかし、この例の場合
             同じような処理を繰り返してしまっています。
             <br>
             未知数のリクエストに対応させると、
            </p>
            <pre>var urls = ['/foo.json', '/bar.json', '/baz.json'];
var result = [];
Deferred.forEach(urls, function(url) {
    return request(url).then(function(data) {
        result.push(data);
    });
}).then(function() {
    alert(result);
});</pre>
            <p>
             こんな感じに書くことができます。
             Deferred.repeat を使ってもいいと思います。
            </p>
            <p>
             さらにコンパクトかつ、次の処理待ちという縛りをなくし
             同時実行 (並列処理) として書くなら、
            </p>
            <pre>parallel([
    request('/foo.json'),
    request('/bar.json'),
    request('/baz.json')
]).then(function(result) {
    alert(result);
});</pre>
            <p>
             このように、parallel (Pot.Deferred.parallel) を使うこともできます。
             parallel は、MochiKit でいう DeferredList と同等の処理を可能とします。
             すべての処理が終わった後、次のコールバックが呼ばれます。
             parallel は、オリジナルの JSDeferred.parallel をベースに実装されています。
            </p>
            <p><br></p>
            <p>
             各チェインのコールバック関数の結果は、
             return した値が次のチェインの引数として渡されます。
             <br>
             コールバック関数から return されなかった場合、
             結果値として無視されます。
             <br>
             その場合、前の結果値を引継ぎ次のコールバックに再び渡されます。
             <br>
             コールバック関数スコープ直下に return があるかないかで判断されます。
            </p>
            <pre>begin(function() {
    return 'foo';
}).then(function(res) {
    alert(res); // 'foo'

    // 値を返さずこのコールバックを抜ける

}).then(function(res) {
    // 前のチェインの結果が引き継がれる
    alert(res); // 'foo'

    // 値を返す
    return 'bar';
}).then(function(res) {
    alert(res); // 'bar'
});</pre>
            <h4 id="exception">例外処理</h4>
            <p>
             非同期処理の中で発生した例外は、
             何事もなかったかのように振舞われてしまいます。
            </p>
            <p>
             Pot.Deferred では、これを rescue というメソッドにより捕捉が可能となっています。
            </p>
            <pre>begin(function() {
    alert('begin');
}).then(function() {
    // 定義されていない関数を呼び例外が発生
    undefinedFunc.call();
}).rescue(function(err) {
    // 例外をキャッチ
    alert(err);
}).then(function() {
    // その後も処理を続けられる
    alert('end');
});</pre>
            <p>
             大まかに、このような流れで処理ができます。
            </p>
            <p>
             rescue によるキャッチは、なにも必ず次のチェインでなくても捕捉できます。
            </p>
            <pre>begin(function() {
    alert(1);
    return 1 + 1;
}).then(function(res) {
    alert(res); // 2
    return res + 1;
}).then(function(res) {
    alert(res); // 3
    
    // エラーを発生させる
    throw new Error('error');
}).then(function(res) {
    // エラーが発生したためこのコールバックは実行されない
    alert(res);
    return res + 1;
}).rescue(function(err) {
    // エラーをキャッチ
    alert(err);
    return 'end';
}).then(function(res) {
    alert(res); // 'end'
});</pre>
           <p>
            この例では、 1, 2, 3, 'error', 'end' とアラートされます。
           </p>
           <p>
            then の第一引数のコールバック関数は、成功時のみ実行され
            エラーが発生した場合は無視されます。
           </p>
           <p><br></p>
           <p>
            実際のところ、チェインに必ず rescue を入れるような丁寧な実装は
            そう多くはないと思います。
            <br>
            そのため、エラーが発生していても気づかず実装完了してしまうことがあるかもしれません。
            <br>
            Pot.Deferred は
            そのような事例を防ぐため、
            rescue などによりキャッチされずに終了してしまったチェインは
            Pot.Deferred 側から再び throw するようになっています。
            <br>
            この再スロー機能により、例外を逃さず発見することが可能になっています。
           </p>
           <p><br></p>
           <p>
            例外時、成功時の両方
            つまり何が起きても次のチェインを実行したい場合は、
            ensure メソッドを使います。
           </p>
           <pre>begin(function() {
    return 1;
}).then(function(res) {
    alert(res);
    // ランダムに例外を発生させる
    if (Math.random() * 10 &lt; 5) {
        throw new Error('error');
    } else {
        return res + 1;
    }
}).ensure(function(res) {
    if (isError(res)) {
        alert('エラー: ' + res);
    } else {
        alert('成功: ' + res);
    }
    return 'end';
}).then(function(res) {
    alert(res); // 'end'
});</pre>
            <p>
             このような、エラーなのか成功なのか不明な場合や
             必ず実行したい場合に有用です。
            </p>
            <p>
             isError (Pot.isError) は、
             対象が Error オブジェクトかどうか判別します。
             この例のような場合には特に有用です。
            </p>
            <p>
             then, rescue, ensure それぞれの使用方法は同じです。
             return した値が、次のコールバックの引数に使われます。
            </p>
            <p>
             また、return した値が Pot.Deferred のインスタンスだった場合、
             そのチェインの最終的な値が 次のコールバックの引数に渡されます。
            </p>
            <pre>begin(function() {
    return begin(function() {
        return 'ho';
    }).then(function(res) {
        var d = new Deferred();
        return d.then(function() {
            return res + 'ge';
        }).begin();
    });
}).then(function(res) {
    alert(res);
});</pre>
            <p>
             この例では 'hoge' とアラートされます。
            </p>
            <p>
             Pot.Deferred を返す場合はネストが可能です。
             Pot.Deferred を返し、そのコールバックでも Pot.Deferred を返す、
             といったことが可能です。
             最終的な結果 (return された) 値が次のコールバックの引数として渡されます。
            </p>
            <h4 id="Destructuring-Assignment">分割代入</h4>
            <p>
             チェインのコールバック関数は、
             引数の数を調節して結果値から分割代入 (Destructuring-Assignment) のようなことができます。
            </p>
            <pre>begin(function() {
    // 配列で返す
    return [1, 2, 3];
}).then(function(a, b, c) { // 結果の配列のアイテム数と引数の数を合わせる

    debug(a); // 1
    debug(b); // 2
    debug(c); // 3

    return [c, b, a]; // 逆順にして返す

}).then(function(a, b, c) {
    // 上と逆順になる

    debug(a); // 3
    debug(b); // 2
    debug(c); // 1

    return [c, b, a];

}).then(function(res) { // 通常通り引数一つで取得
    // 引数一つの時は分割代入されない

    debug(res); // [1, 2, 3]

});</pre>
            <p><br></p>
            <h4 id="controlSpeed">速度の操作</h4>
            <p>
             Pot.Deferred は、コールバックチェインの速度を変更することができます。
            </p>
            <pre>var d = new Deferred();
// 速度を遅くする
d.speed('slow');

d.then(function() {
    console.log(1);
}).then(function() {
    console.log(2);
}).then(function() {
    console.log(3);
}).begin();</pre>
            <p>
             こうすることで、各コールバックはゆっくり実行されます。
             <br>
             この例では、console.log() が 1, 2, 3 とゆっくり表示されます。
            </p>
            <p>
             速度の指定は、speed メソッドにより指定できます。
             定義された値の文字列、または数値 (ms) で指定できます。
             定義された文字列値は 下の表 を参照ください。
            </p>
            <div>
             <table class="grid" id="controlSpeedMap">
              <tr>
               <td class="marker header" style="width: 49%">値 / メソッド名</td>
               <td class="marker header" style="width: 49%">速度</td>
              </tr>
              <tr>
               <td>limp</td>
               <td>最も遅い</td>
              </tr>
              <tr>
               <td>doze</td>
               <td>遅い</td>
              </tr>
              <tr>
               <td>slow</td>
               <td>遅め</td>
              </tr>
              <tr>
               <td>normal</td>
               <td>通常</td>
              </tr>
              <tr>
               <td>fast</td>
               <td>速め</td>
              </tr>
              <tr>
               <td>rapid</td>
               <td>速い</td>
              </tr>
              <tr>
               <td>ninja</td>
               <td>最も速い</td>
              </tr>
             </table>
            </div>
            <p>
             または、コンストラクタに引数のオプションとして渡すことができます。
            </p>
            <pre>var d = new Deferred({ speed : 'slow' });</pre>
            <p>
             コールバックチェインの途中で速度を変更することも可能です。
            </p>
            <pre>var d = new Deferred();
d.then(function() {
    console.log(1);
}).speed('slow').then(function() {
    console.log(2);
    return 2 + 1;
}).speed(5000).then(function(res) {
    console.log(res); // 3
}).begin();</pre>
            <p>
             上の例のように、コールバック関数を用いないメソッドは
             結果の値を引き継ぎ、次のコールバックに渡します。
             <br>
             したがって、speed() や wait() などを使用しても
             次のコールバックに渡す引数の値が失われることはありません。
            </p>
            <p>
             何らかの重い処理を分割して処理する場合、speed の指定により負荷を軽減できます。
            </p>
            <pre>begin(function() {
    return someHeavyProcess();
}).speed('slow').then(function(res) {
    return moreHeavyProcess(res);
}).speed('doze').then(function(res) {
    return mostHeavyProcess(res);
}).speed('normal').then(function(res) {
    alert(res);
});</pre>
            <p>
             途中で wait を置くことも可能です。
            </p>
            <pre>begin(function() {
    return someHeavyProcess();
}).speed('slow').wait(1).then(function(res) {
    return moreHeavyProcess(res);
}).speed('doze').wait(2).then(function(res) {
    return mostHeavyProcess(res);
}).speed('normal').then(function(res) {
    alert(res);
});</pre>
            <p>
             wait は、秒数を引数に設定します。
             ミリ秒ではないので注意してください。
            </p>
            <h4 id="fireChain">チェインを実行</h4>
            <p>
             今までの例の途中でもいくつか出ましたが、
             <br>
             .begin() メソッドによりチェインを開始することができます。
            </p>
            <p>
             関数としての begin (Pot.Deferred.begin) は、
             Deferred のインスタンスを生成し、
             チェインを開始するショートカットのようなものです。
             別ものなので注意してください。
            </p>
            <pre>var d = new Deferred();
d.then(function() {
    alert('hoge');
});</pre>
            <p>
             この例は、何も実行されません。
             'hoge' とアラートもされません。
             <br>
             単に変数 d にコールバックを登録しただけです。
            </p>
            <p>
             これを実行するには、
            </p>
            <pre>d.begin();</pre>
            <p>
             とすると、コールバックチェインが開始されます。
            </p>
            <p>
             また、引数に値を設定することができます。
            </p>
            <pre>var d = new Deferred();
d.then(function(value) {
    alert(value);
}).begin('hoge');</pre>
            <p>
             この例では、hoge とアラートされます。
            </p>
            <p>
             次 (この場合は最初) のコールバックの引数の値として渡すことができます。
            </p>
            <p>
             また、何らかの事態により .begin を通常処理ではなくエラーと扱いたい場合は、
            </p>
            <pre>var d = new Deferred();
d.then(function() {
    // 成功時
    successFunc();
}).rescue(function() {
    // エラー時
    errorFunc();
}).ensure(function() {
    // 最終的な処理
    finallyFunc();
});
// チェックが通れば成功とする場合
if (check()) {
    d.begin();
} else {
    d.raise();
}</pre>
            <p>
             このような分岐が必要な場合、
             .begin() のかわりに .raise() を実行することで
             エラー扱いでコールバックチェインを開始することができます。
             <br>
             エラーから始まるので、最初に then があった場合は そのコールバックは無視されます。
            </p>
            <p>
             .raise() も同様に、引数に何らかの値を与え
             次のエラーバック関数の引数として渡すことができます。
            </p>
            <h3 id="replaceToDeferred">関数を Deferred 化</h3>
            <p>
             既存の関数や、ユーザー定義の関数を Deferred 化、
             つまり Pot.Deferred のインスタンスが返るよう置き換えたり
             自分で作成する必要がでてくるかもしれません。
            </p>
            <p>
             例として、XMLHttpRequest を使った非同期処理を書いてみます。
            </p>
            <pre>function request(url, options) {
    var deferred = new Deferred();
    var xhr = new XMLHttpRequest();
    if (options.queryString) {
      url += options.queryString;
    }
    xhr.open(options.method, url, true);
    xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
            if (xhr.status == 200) {
                deferred.begin(xhr);
            } else {
                deferred.raise(xhr);
            }
        }
    };
    deferred.canceller(function() {
        xhr.abort();
    });
    xhr.send(options.sendContent || null);
    return deferred;
}</pre>
            <p>
             request 関数は、上のほうで例としてあげたものですが、
             PotLite.js 内にも定義されています。
             <br>
             この例は、それを簡略化したものです。
            </p>
            <p>
             Deferred を返すには、new Deferred としたものや、
             Pot.Deferred.begin() のような
             あらかじめ定義されていて Deferred を返す関数を利用する必要があります。
            </p>
            <p>
             接続が成功したら begin() を、失敗したら raise() をコールしています。
             <br>
             関数を定義する場合、エラー処理を明示してあげることで
             より適切な処理になります。
            </p>
            <p>
             また、canceller() によりキャンセル処理を追加しています。
             <br>
             Deferred のキャンセルは、
            </p>
            <pre>deferred.cancel();</pre>
            <p>
             とすることで任意にコールバックチェインの実行を中止
             または中断できます。
            </p>
            <p>
             Pot.Deferred では、キャンセル処理としてのコールバック関数を
             スタッカブルに保持します。
             <br>
             なので、canceller() メソッドにより複数のコールバックが登録できます。
            </p>
            <p>
             PotLite.js では、request 関数のほかに
             jsonp 関数も定義されています。
             <br>
            </p>
            <p>
             jsonp 関数は、そのままの意味で JSONP によるデータ取得を行います。
            </p>
            <p>
             使用方法、引数などは request, jsonp 共にほぼ同じで
             返り値に XHR を設定された Deferred を返します。
            </p>
            <p><br></p>
            <p>
             他にも関数を Deferred 化するための方法があり、
             <br>
             deferrize (Pot.Deferred.deferrize) という関数が Pot.Deferred オブジェクトに定義されています。
            </p>
            <pre>// setTimeout を Deferred 化する
var timer = deferrize(window, 'setTimeout');

// setTimeout と同じ引数
timer(function() {
    debug(1);
}, 5000).then(function() {
    debug(2);
});</pre>
            <p>
             上の例は、setTimeout を Deferred 化し、それを実行します。
            </p>
            <p>
             5 秒待ってから、
             debug 関数によりコンソールに 1, 2 と出力されます。
            <p>
             deferrize はコールバック関数を引数とする場合は、
             その関数の処理が終わった後に Deferred を開始し、
             関数を引数として扱わないものは
             処理が全て終わったあとに Deferred を開始します。
             途中でエラーが起きると raise() により開始されます。
             <br>
             したがって、処理自体を置き換えたい場合でなければ
             大抵の関数は deferrize で Deferred 化できます。
            </p>
            <p>
             もっと複雑な置き換えをする場合や、
             自前で Deferred 関数を作成したりする場合、
             new Deferred や Pot.Deferred オブジェクトの関数などを使用して
             より細かな処理を独自に作成することができます。
            </p>
           </div>
           <h3 id="iterator">イテレータ</h3>
           <div>
            <p>
             Pot.js は、MochiKit ライクな実装の Deferred を中心に
             非同期のループ、イテレートを重視して作られています。
             <br>
             (ここで言う MochiKit ライクとは、
              コールバックチェインがひとつのインスタンスであるということです。)
            </p>
            <p>
             また、JSDeferred の概要を強く尊重しています。
            </p>
            <p>
             <a href="http://cho45.stfuawsc.com/jsdeferred/doc/intro.html"
                title="JSDeferred 紹介">JSDeferred 紹介</a> より引用：
            </p>
            <blockquote>
             <p>
              JavaScript における「高速化」
             </p>
             <p>
              JavaScript における「高速化」では、単純に処理速度の高速化というよりは、
              ユーザ体験のストレスをいかになくすかがとても重要です。
             </p>
            </blockquote>
            <p>
             いくつにもネストした JavaScript のループ (for, for-in, while など) は、
             <br>
             特に Web ブラウザ上で実行される場合
             処理が重たくなりがちです。
            </p>
            <p>
             そこで、Pot.js は、非同期処理を直列的に書けるようにする Deferred を活用し、
             <br>
             forEach, map, reduce, filter, some, every, repeat, forEver 
             などといったイテレート関数と結びつけ、
             <br>
             各ループ間の処理の重さを計算し、
             自動的に CPU 負荷が軽減するよう調整しています。
             <br>
             そして、更なるストレス軽減を目標としています。
            </p>
            <p>
             イテレートは、同期または非同期、Deferred チェイン上などで実行が可能です。
            </p>
            <p>
             同期でのシンプルなオブジェクトのイテレートの場合、for-in では
            </p>
            <pre>for (var key in object) {...}</pre>
            <p>
             となりますが、Pot.js の forEach を使うと、
            </p>
            <pre>forEach(object, function(value, key) {...});</pre>
            <p>
             となります。
             <br>
             非同期でループする場合は、
            </p>
            <pre>Deferred.forEach(object, function(value, key) {...})</pre>
            <p>
             となり、Pot.Deferred のインスタンスを返します。
             Pot.globalize() してない場合は Pot.Deferred.forEach です。
            </p>
            <p>
             Deferred チェイン上で実行する場合も同じ扱いですが、引数が異なります。
            </p>
            <pre>(new Deferred()).forEach(function(value, key) {...}).begin([1, 2, 3]);</pre>
            <p>
             各ループは、コールバック関数の処理の重さにより負荷がかからないよう
             自動調節します。
             <br>
             この処理をすることで、例えば 10000 程の多くのアイテム数を持つ配列に対して
             for でループした場合と
             Deferred.forEach などのイテレータで実行した場合、
             <br>
             全体の処理の重さは大きな差が出ます。
             <br>
             また、それにより Web ブラウザによって発行される、
             <br>
             「処理が重くなっています、中断しますか？」
             などのメッセージを回避することもできます。
            </p>
            <p>
             Deferred に関連する イテレータのすべては、速度を調整することができます。
             <br>
             各ループをゆっくり実行したい場合は、
            </p>
            <pre>Deferred.forEach.slow(obj, function() {...});</pre>
            <p>
             逆に速くしたい場合は、
            </p>
            <pre>Deferred.forEach.fast(obj, function() {...});</pre>
            <p>
             などの指定が可能です。
             <br>
             他には 遅い順に limp, doze, slow, normal, fast, rapid, ninja が指定可能です。
             速度の指定値については、<a href="#controlSpeedMap">上の速度の表</a> を参照ください。
             <br>
             その場に応じて使い分けができます。
            </p>
            <p>
             時間のかかるループだけでなく、
             <br>
             瞬間的に負荷がかかり
             Web ブラウザが頻発して一瞬だけ固まる、といった事例もあげられます。
             <br>
             そのような処理も、1 回で済まそうとしないで分割することで解消できます。
            </p>
            <p>
             例えば DOM 要素を大量に扱って操作する場合、
            </p>
            <pre>// ものすごい巨大なページだったとします。
var elems = document.getElementsByTagName('*');</pre>
            <p>
             従来通りループする場合、
            </p>
            <pre>var len = elems.length;
for (var i = 0; i &lt; len; i++) {
    var elem = elems[i];
    someHeavyProcess(elem); // 何らかの重い処理
}</pre>
            <p>
             この方法では休む間を与えられず、UI が固まっていても容赦なく処理が続行されてしまいます。
            </p>
            <p>
             これを Pot.Deferred を使って書くと、
            </p>
            <pre>Deferred.repeat(elems.length, function(i) {
    var elem = elems[i];
    someHeavyProcess(elem); // 何らかの重い処理
});</pre>
            <p>
             一見あまり変化なさそうですが、
             1 ループごとに処理の負荷を計算して
             ある程度重いと判断した場合は Web ブラウザに制御を返し、
             UI を独占しないよう調節します。
            </p>
            <p>
             または、forEach を使うこともできます。
            </p>
            <pre>Deferred.forEach(elems, function(elem) {
    someHeavyProcess(elem); // 何らかの重い処理
});</pre>
            <p>
             someHeavyProcess() と 1 つの関数だけで表現しましたが、
             <br>
             これが、someHeavyProcess1, someHeavyProcess2, ... と
             いくつかの関数で構成されている場合、
            </p>
            <pre>Deferred.forEach(elems, function(elem) {
    return begin(function() {
        someHeavyProcess1(elem);
    }).wait(1).then(function() {
        someHeavyProcess2(elem);
    }).wait(1).then(function() {
        someHeavyProcess3(elem);
    });
});</pre>
            <p>
             このように分割し、任意に wait などを入れることが可能です。
            </p>
            <p>
             なお、begin (Pot.Deferred.begin) は、
             Pot.Deferred オブジェクトのインスタンスを返すので
             Deferred.forEach などの中で実行する場合、
             return が必要です。
             return しないと整合性がとれなくなってしまいます。
            </p>
            <p>
             それでも重い場合、
            </p>
            <pre>Deferred.forEach.slow(elems, function(elem) {
    someHeavyProcess(elem);
});</pre>
            <p>
             ゆっくり実行することを明示し slow を指定して速度を調整できます。
            </p>
            <p>
             slow の次に遅い doze にすると、必ず毎回のループごとに
             Web ブラウザに制御を返します。
             <br>
             結果として処理時間は長くなりますが、
             途中で固まったりカクカクするようなことが避けられます。
            </p>
            <p>
             速度指定は 'メソッド.速度()' の形式で利用できます。
             <br>
             例えば、 'forEach.rapid(...)' のような指定です。
             <br>
             forEach, repeat, map, filter など、すべてのイテレータで指定可能です。
            </p>
            <p>
             定義された速度の値は、<a href="#controlSpeedMap">上の速度の表</a> を参照してください。
            </p>
            <p>
             速度指定の表にある 「最も速い」 という表記は、
             <br>
             逆に言うと
             最も負荷をかけやすいとも言えます。
             <br>
             とはいっても for-in などでループすることと比べたら
             UI への配慮は少なからず存在するという差はあります。
            </p>
            <p>
             大抵は自ら速度調整する必要はありませんが、
             特殊な用途やデバッグ時など、必要になることもあります。
            </p>
            <h3 id="replaceLoop">ループ処理を置き換える</h3>
            <p>
             既存のループで負荷がかかっている処理を、
             Pot.js のイテレータを用いて軽減させることができます。
            </p>
            <pre>function someLoop(n, c) {
    var results = [];
    for (var i = 0; i &lt; n; i++) {
        var array = [];
        for (var j = 0; j &lt; c; j++) {
            array[j] = j;
        }
        results[i] = array;
    }
    return results;
}</pre>
            <p>
             例えばこのような関数があったとします。
             <br>
             引数 c 回ループした配列を引数 n 個分持つ配列を返す関数です。
            </p>
            <p>
             例えばこれを、
            </p>
            <pre>var array = someLoop(100000, 1000);</pre>
            <p>
             このような大きい配列を作るとなると、
             スペックにもよりますが、
             瞬間的な負荷は大きくなり UI を独占してしまうでしょう。
            </p>
            <p>
             この関数を Deferred 化してみます。
            </p>
            <pre>function someLoopDefer(n, c) {
    var results = [];
    return Deferred.repeat(n, function(i) {
        var array = [];
        for (var j = 0; j &lt; c; j++) {
            array[j] = j;
        }
        results[i] = array;
    }).then(function() {
        return results;
    });
}</pre>
            <p>
             例として、このようになります。
             <br>
             内側の for はこのままでいいのかと思うかもしれませんが、
             おそらく repeat、Deferred.repeat 等に変えたところで
             必要以上に負荷が分散され、結果としてかなり速度は落ちてしまうでしょう。
             <br>
             なので、いちばん外側のループのみを置き換えます。
             <br>
             もっとも、この例の場合は
             内側の for を何度も実行する必要はありませんが、
             あくまで例です。
             <br>
             返り値は Deferred になります。
            </p>
            <pre>someLoopDefer(100000, 1000).then(function(res) {
    var array = res;
});</pre>
            <p>
             Deferred が返るので、then などで結果を取得します。
             そのままチェインを繋げることもできます。
            </p>
            <p>
             この変化により、瞬間的な処理の重さが分散され
             安定した処理が可能となります。
             <br>
             そのかわり、処理時間は若干伸びる可能性があります。
            </p>
            <p>
             Pot.Deferred のイテレータを使う場合、
             このように
             あまり意識せずに分散的なループが可能となります。
            </p>
            <h3 id="StopIteration">イテレートを止める</h3>
            <p>
             Pot.js, PotLite.js で実装されている
             すべてのイテレータは、
             <br>
             StopIteration を throw することで中断できます。
            </p>
            <pre>var foo = '';
forEver(function(i) {
    foo += 'foo';
    if (foo.length &gt; 10) {
        throw StopIteration;
    }
});
debug(foo);</pre>
            <p>
             この例は、debug 関数により
             コンソールに 'foofoofoofoo' と出力されます。
            </p>
            <p>
             forEver (Pot.forEver) は、StopIteration が throw されるまで
             永遠にループします。
             <br>
             複雑な条件式でループを制御する場合や、
             そのような既存の重い処理を
             Deferred.forEver で置き換えたい場合などに活用できます。
            </p>
            <p>
             StopIteration は、 Array.prototype.forEach が有効な環境など、
             コンフリクトする可能性があるときは
             Pot.StopIteration と明示することで解消できます。
            </p>
            <p>
             StopIteration を判別する方法は、
            </p>
            <pre>if (isStopIter(e)) {...}</pre>
            <p>
             または、
            </p>
            <pre>if (e == StopIteration) {...}</pre>
            <p>
             と単純に比較か、
            </p>
            <pre>if (e instanceof StopIteration) {...}</pre>
            <p>
             とすることもできます。
            </p>
            <p>
             おそらく Pot.js ライブラリが実装している
             isStopIter (Pot.isStopIter) が確実です。
            </p>
            <p><br></p>
            <p>
             実装されているすべてのイテレータは、
             コールバック関数が非同期の Deferred オブジェクトを
             いくつにもネストしたとしても、
             <br>
             throw StopIteration によりスコープ間を超えて
             実行中のイテレータ関数のスコープまで届くよう設計されています。
            </p>
            <pre>var result = [];
begin(function() {
    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
}).forEach(function(value) {
    return begin(function() {
        var d = new Deferred();
        return d.then(function() {
            if (value &gt; 5) {

                // 実行しているイテレータのスコープが対象になるため
                // この例では いちばん外側の .forEach まで届く

                throw StopIteration;
            }
            return value * 100;
        }).begin();
    }).then(function(res) {
        result.push(res);
    });
}).then(function() {
    debug(result);
    //  =&gt;  [100, 200, 300, 400, 500]
});</pre>
           </div>
           <h3 id="referenceFunctions">関数リファレンス</h3>
           <div>
            <p>
             Pot.js および PotLite.js には、
             他にも汎用的に使える関数が用意されています。
            </p>
            <p>
             以降、簡単に主な関数を説明します。
             Pot.js, PotLite.js の全ての関数ではありません。
             <br>
             より詳しくは、ソースコードから自動生成された
             <a href="jsdoc/potlite/index.html"
                title="PotLite.js - JsDoc Reference - Index">JSDoc ドキュメント (PotLite.js)</a>
             または直接ソースコードを参照ください。
            </p>
            <p><br></p>
            <h4 id="PotObjectFunctions">Pot オブジェクトの関数</h4>
            <p>
             以下の関数は、Pot オブジェクトから実行できる
             static な関数です。
             <br>
             Pot.globalize() がされてない場合、
             Pot.xxx としてアクセスできます (e.g. Pot.update)。
             <br>
             Pot.globalize() が適応済みの場合、
             定義名のままで呼び出せます。
            </p>
            <dl>
             <dt>
              <dfn id="function.Pot.update"><em>Pot.</em>update</dfn>(target, ...)
             </dt>
             <dd>
              オブジェクト target をアップデート。
              <br>
              mixin のようなものです。
              <br>
              第一引数のアップデートするオブジェクト以降は可変で、
              プロパティは上書きされるため
              最終的な要素が最も影響します。
              <pre>var obj = {foo: 'v1', bar: 'v2'};
var src = {baz: 'v3'};
update(obj, src);
debug(obj);
// obj = {foo: 'v1', bar: 'v2', baz: 'v3'}</pre>
              シンプルにオブジェクトのコピーを作成できます。
              <pre>var obj = {foo: 1, bar: 2, baz: 3};
var copy = update({}, obj);
debug(copy); // {foo: 1, bar: 2, baz: 3}</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.stringify"><em>Pot.</em>stringify</dfn>(x)
             </dt>
             <dd>
              任意の値 x を文字列として評価して返します。
              <br>
              String, Number などのいわゆるスカラー型のみに限定します。
              E4X が使用できる環境では、XML オブジェクトも適応され toString() されて返ります。
              <br>
              かならず文字列が返り、
              Object や Function, false, null, undefined 等は空文字 '' が返ります。
              true は '1' になります。
              <pre>stringify({});                // ''
stringify([]);                // ''
stringify(0);                 // '0'
stringify(-100.02);           // '-100.02'
stringify(new Date());        // ''
stringify(null);              // ''
stringify((void 0));          // ''
stringify(false);             // ''
stringify(true);              // '1'
stringify('');                // ''
stringify('hoge');            // 'hoge'
stringify(new String('hoge'); // 'hoge'
stringify(new Boolean(false); // ''
stringify(new Boolean(true);  // '1'
stringify([100]);             // ''</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.arrayize"><em>Pot.</em>arrayize</dfn>(o, index)
             </dt>
             <dd>
              任意の値 o を配列として返します。
              <br>
              index が指定されるとそこから slice して返します。
              <br>
              Array.prototype.slice を改良したようなものです。
              <br>
              NodeList や arguments などに適応すると便利です。
              配列はコピー扱いで返ります。
              <pre>arrayize(null);               // [null]
arrayize((void 0));           // [undefined]
arrayize(true);               // [true]
arrayize(false);              // [false]
arrayize('');                 // ['']
arrayize('hoge');             // ['hoge']
arrayize([]);                 // []
arrayize(new Array(1, 2, 3)); // [1, 2, 3]
arrayize([1, 2, 3]);          // [1, 2, 3]
arrayize([[]]);               // [[]]
arrayize([[100]]);            // [[100]]
arrayize({});                 // [{}]
arrayize({foo: 'bar'});       // [{foo: 'bar'}]
arrayize(document.getElementsByTagName('div')); // [&lt;div/&gt;, &lt;div/&gt;, ...]

(function(a, b, c) {
    arrayize(arguments); // [1, 2, 3]
})(1, 2, 3);

(function(a, b, c) {
    arrayize(arguments, 2); // [3]
})(1, 2, 3);</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.rescape"><em>Pot.</em>rescape</dfn>(s)
             </dt>
             <dd>
              文字列 s を正規表現パターンとみなしエスケープして返します。
              <pre>var pattern = '*[hoge]*';
var regex = new RegExp('^(' + rescape(pattern) + ')$', 'g');
debug(regex.toString()); // =&gt; /^(\*\[hoge\]\*)$/g</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.trim"><em>Pot.</em>trim</dfn>(s[, chars])
             </dt>
             <dd>
              文字列 s の両端の (全角スペース U+3000 含む) ホワイトスペースを除去して返す。
              <br>
              文字列 chars が指定されると、スペースの代わりに chars を除去して返す。
              <pre>debug( trim(' hoge  ') );          // 'hoge'
debug( trim('abbbcc cca ', 'ab') ); // 'cc cca '</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.now"><em>Pot.</em>now</dfn>()
             </dt>
             <dd>
              Date.now or (new Date.getTime()) と同じ。
             </dd>
             <dt>
              <dfn id="function.Pot.debug"><em>Pot.</em>debug</dfn>(msg)
             </dt>
             <dd>
              デバッグ用として、引数の値をコンソールに出力する。(cross-browser)
             </dd>
             <dt>
              <dfn id="function.Pot.isBoolean"><em>Pot.</em>isBoolean</dfn>(x)
             </dt>
             <dt>
              <dfn id="function.Pot.isNumber"><em>Pot.</em>isNumber</dfn>(x)
             </dt>
             <dt>
              <dfn id="function.Pot.isString"><em>Pot.</em>isString</dfn>(x)
             </dt>
             <dt>
              <dfn id="function.Pot.isFunction"><em>Pot.</em>isFunction</dfn>(x)
             </dt>
             <dt>
              <dfn id="function.Pot.isArray"><em>Pot.</em>isArray</dfn>(x)
             </dt>
             <dt>
              <dfn id="function.Pot.isDate"><em>Pot.</em>isDate</dfn>(x)
             </dt>
             <dt>
              <dfn id="function.Pot.isRegExp"><em>Pot.</em>isRegExp</dfn>(x)
             </dt>
             <dt>
              <dfn id="function.Pot.isObject"><em>Pot.</em>isObject</dfn>(x)
             </dt>
             <dt>
              <dfn id="function.Pot.isError"><em>Pot.</em>isError</dfn>(x)
             </dt>
             <dd>
              それぞれ 適性のオブジェクトかどうか調べて適正なら true を返す。
              <pre>debug( isArray([1, 2, 3]) ); // true
debug( isArray('hoge') );    // false</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.typeOf"><em>Pot.</em>typeOf</dfn>(x)
             </dt>
             <dd>
              x の型を文字列で返す (例えば 'array', 'object', 'null')
              <pre>typeOf([1, 2, 3]); // 'array'</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.isStopIter"><em>Pot.</em>isStopIter</dfn>(x)
             </dt>
             <dd>
              x が StopIteration なら true を返す。
              <pre>try {
    throw StopIteration;
} catch (e) {
    debug( isStopIter(e) ); // true;
    try {
        throw Pot.StopIteration;
    } catch (ex) {
        debug( isStopIter(ex) ); // true
        try {
            throw new Error('hoge');
        } catch (err) {
            debug( isStopIter(err) ); // false
        }
    }
}</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.isIterable"><em>Pot.</em>isIterable</dfn>(x)
             </dt>
             <dd>
              x がイテレートできるなら true を返す。
              <br>
              ここでいうイテレート可能とは、
              Pot.iterate() によるイテレートが可能ということです。
              <br>
              Pot.Iter のインスタンスまたは yield によって生成したジェネレータが含まれます。
              <pre>var iter = new Iter(); // Pot.Iter
var i = 0;
iter.next = function() {
    if (i &gt; 5) {
        throw StopIteration;
    }
    return i++;
};
debug( isIterable(iter) ); // true

var func = function() {};
debug( isIterable(func) ); // false</pre>
              <pre>var iter = (function() {
    for (var i = 0; i &lt; 10; i++) {
        yield;
        debug(i);
    }
})();
debug( isIterable(iter) ); // true</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.isArrayLike"><em>Pot.</em>isArrayLike</dfn>(x)
             </dt>
             <dd>
              isArray との違いは、arguments や NodeList も true として返す点。
              <pre>(function() {
    debug( isArray(arguments) );     // false
    debug( isArrayLike(arguments) ); // true
})();</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.isDeferred"><em>Pot.</em>isDeferred</dfn>(x)
             </dt>
             <dd>
              x が Pot.Deferred のインスタンスなら true を返す。
              <pre>var o = {hoge: 1};
var d = new Deferred();
debug( isDeferred(o) ); // false
debug( isDeferred(d) ); // true</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.isIter"><em>Pot.</em>isIter</dfn>(x)
             </dt>
             <dd>
              x が Pot.Iter のインスタンスなら true を返す。
             </dd>
             <dt>
              <dfn id="function.Pot.isNumeric"><em>Pot.</em>isNumeric</dfn>(x)
             </dt>
             <dd>
              x が数えられる値なら true を返す。 (1, -1, 1e8, '10', '0xFF' など)。
              <pre>debug(isNumeric(0));               // true
debug(isNumeric(1234567890));      // true
debug(isNumeric(new Number(25)));  // true
debug(isNumeric(null));            // false
debug(isNumeric((void 0)));        // false
debug(isNumeric('abc'));           // false
debug(isNumeric('0xFF'));          // true
debug(isNumeric('1e8'));           // true
debug(isNumeric('10px'));          // false
debug(isNumeric('-512 +1'));       // false
debug(isNumeric([]));              // false
debug(isNumeric([100]));           // false
debug(isNumeric(new Date()));      // false
debug(isNumeric({}));              // false
debug(isNumeric((function() {}))); // false</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.isInt"><em>Pot.</em>isInt</dfn>(x)
             </dt>
             <dd>
              x が整数なら true を返す。
              <pre>debug(isInt(0));                       // true
debug(isInt(-524560620));              // true
debug(isInt(0.1205562));               // false
debug(isInt(1.5));                     // false
debug(isInt(12345));                   // true
debug(isInt(Number.MAX_VALUE));        // true
debug(isInt(Number.MAX_VALUE * 1000)); // false
debug(isInt(null));                    // false
debug(isInt((void 0)));                // false
debug(isInt('hoge'));                  // false
debug(isInt(''));                      // false
debug(isInt([100]));                   // false</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.isBuiltinMethod"><em>Pot.</em>isBuiltinMethod</dfn>(func)
             </dt>
             <dd>
              func がビルトイン関数なら true を返す。
              <br>
              例えば encodeURI を渡すと true を返す。
              <pre>debug(isBuiltinMethod((function() {})));          // false
debug(isBuiltinMethod(Array.prototype.slice));    // true
debug(isBuiltinMethod(encodeURIComponent));       // true
debug(isBuiltinMethod(document.getElementById));  // true</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.isWindow"><em>Pot.</em>isWindow</dfn>(x)
             </dt>
             <dd>
              x が window オブジェクトなら true を返す。
              <pre>debug(isWindow(window));                               // true
debug(isWindow(document));                             // false
debug(isWindow(document.body));                        // false</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.isDocument"><em>Pot.</em>isDocument</dfn>(x)
             </dt>
             <dd>
              x が document オブジェクトなら true を返す。
              <pre>debug(isDocument(window));                               // false
debug(isDocument(document));                             // true
debug(isDocument(document.body));                        // false</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.isElement"><em>Pot.</em>isElement</dfn>(x)
             </dt>
             <dd>
              x が DOM Element オブジェクトなら true を返す。
              <pre>debug(isElement(window));                               // false
debug(isElement(document));                             // false
debug(isElement(document.body));                        // true
debug(isElement(document.getElementById('container'))); // true (if exists)
debug(isElement(document.getElementsByTagName('div'))); // false</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.isNodeList"><em>Pot.</em>isNodeList</dfn>(x)
             </dt>
             <dd>
              x が DOM NodeList なら true を返す。
              <pre>var obj = new Array({foo: 1, bar: 2, baz: 3});
var nodes = document.getElementsByTagName('div');
debug(isNodeList(obj));   // false
debug(isNodeList(nodes)); // true</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.isNodeLike"><em>Pot.</em>isNodeLike</dfn>(x)
             </dt>
             <dd>
              x が DOM Node のようなものなら true を返す。
              <pre>debug(isNodeLike(window));                               // false
debug(isNodeLike(document));                             // true
debug(isNodeLike(document.body));                        // true
debug(isNodeLike(document.getElementById('container'))); // true (if exists)
debug(isNodeLike(document.getElementsByTagName('div'))); // false</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.range"><em>Pot.</em>range</dfn>([begin,] end[, step])
             </dt>
             <dd>
              begin から end までを step のステップで得られた値を配列で返す。
              <br>
              例:
              <pre>range(1, 5);     // [1, 2, 3, 4, 5]
range('a', 'f'); // ['a', 'b', 'c', 'd', 'e', 'f']</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.indexOf"><em>Pot.</em>indexOf</dfn>(object, subject[, from])
             </dt>
             <dd>
              オブジェクトにも使える Array.prototype.indexOf のようなもの。
              <br>
              例:
              <pre>indexOf([2, 5, 9], 2); // 0
indexOf([2, 5, 9], 7); // -1
indexOf({a: 2, b: 5, c: 9}, 2); // 'a'
indexOf({a: 2, b: 5, c: 9}, 7); // -1</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.lastIndexOf"><em>Pot.</em>lastIndexOf</dfn>(object, subject[, from])
             </dt>
             <dd>
              オブジェクトにも使える Array.prototype.lastIndexOf のようなもの。
              <pre>lastIndexOf([2, 5, 9, 2], 2);        // 3
lastIndexOf([2, 5, 9, 2], 7);        // -1
lastIndexOf([2, 5, 9, 2], 2, 3);     // 3
lastIndexOf([2, 5, 9, 2], 2, 2);     // 0
lastIndexOf([2, 5, 9, 2], 2, -2);    // 0
lastIndexOf([2, 5, 9, 2], 2, -1);    // 3

lastIndexOf({a: 2, b: 5, c: 9, d: 2}, 2);      // 'd'
lastIndexOf({a: 2, b: 5, c: 9, d: 2}, 7);      // -1
lastIndexOf({a: 2, b: 5, c: 9, d: 2}, 2, 'd'); // 'd'
lastIndexOf({a: 2, b: 5, c: 9, d: 2}, 2, 'c'); // 'a'</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.request"><em>Pot.</em>request</dfn>(url[, options])
             </dt>
             <dd>
              XMLHttpRequest によるリクエストを実行します。
              <br>
              XMLHttpRequest のない環境 (Node.js など) では
              http/https request によるリクエストを実行します。
              返り値などは同じに扱えます (responseText で取得できるなど)。
              <br>
              返り値に XHR レスポンスを設定した
              Pot.Deferred のインスタンスが返ります。
              <pre>request('/data.cgi', {
    method : 'POST',
    sendContent : {
        query  : 'Book OR Media', // 文字列は URL エンコードされる
        start  : 0,
        length : 15,
        format : 'json'
    },
    mimeType : 'application/json',
    headers  : {
        'User-Agent'   : 'Pot.js',
        'Content-Type' : 'text/javascript'
    }
}).then(function(res) {
    debug(res.responseText);
}, function(err) {
    debug('Error!');
    debug(err);
});</pre>
              <br>
              options で使用できるキー(すべて任意):
              <dl>
               <dt><em>{String}</em> <dfn>method</dfn></dt>
               <dd>
                HTTP メソッド (デフォルト = 'GET')
                <br>
                例: 'GET', 'POST', 'HEAD' etc.
               </dd>
               <dt><em>{Object}</em> <dfn>sendContent</dfn></dt>
               <dd>
                POST 時に送るデータ。
                <br>
                queryString と同じ指定の仕方ができる。
                <br>
                例: {data: 'hoge', data2: 'fuga'}
               </dd>
               <dt><em>{Object}</em> <dfn>queryString</dfn></dt>
               <dd>
                GET 時に送るデータ。
                <br>
                sendContent と同じ指定の仕方ができる。
                <br>
                例: {q: '秋場所', hl: 'ja'}
               </dd>
               <dt><em>{String}</em> <dfn>username</dfn></dt>
               <dd>
                Basic 認証時に使用するユーザー名。
                <br>
                例: 'hoge'
               </dd>
               <dt><em>{String}</em> <dfn>password</dfn></dt>
               <dd>
                Basic 認証時に使用するパスワード。
                <br>
                例: 'hogepass'
               </dd>
               <dt><em>{Object}</em> <dfn>headers</dfn></dt>
               <dd>
                送信するヘッダー。
                <br>
                例: {'Content-Type': 'text/javascript'}
               </dd>
               <dt><em>{String}</em> <dfn>mimeType</dfn></dt>
               <dd>
                MIMEType を指定する場合。
                <br>
                例: 'text/javascript'
               </dd>
              </dl>
             </dd>
             <dt>
              <dfn id="function.Pot.jsonp"><em>Pot.</em>jsonp</dfn>(url[, options])
             </dt>
             <dd>
              JSONP による通信でデータを取得。
              <br>
              Pot.Deferred のインスタンスが返る。
              <br>
              options は request 関数と同じ (いくつかは無効)。
              <br>
              queryString, callback が使用可能。
              <br>
              例:
              <pre>// jQuery.getJSON と同じ URL コールバックの指定が可能
var url = 'http://www.example.com/jsonpTest?callback=?';
jsonp(url, {
    queryString : {
        q : 'JavaScript OR ECMAScript' // 文字列は URL エンコードされる
    }
}).then(function(data) {
    debug(data.results[0].text);
});</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.loadScript"><em>Pot.</em>loadScript</dfn>(url[, options])
             </dt>
             <dd>
              非同期でスクリプトを読み込みます。
              <br>
              Pot.Deferred のインスタンスが返ります。
              <br>
              Web ブラウザ上では、&lt;script&gt; 要素を使います。
              <br>
              それ以外の環境では Pot.request 関数によりスクリプトを取得し評価します。
              <br>
              スクリプトはグローバルスコープで評価されます。
              <br>
              例:
              <pre>loadScript('http://www.example.com/hoge.js').then(function() {
    // この時点でスクリプトは評価済み
    var result = hoge();
});</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.serializeToJSON"><em>Pot.</em>serializeToJSON</dfn>(value)
             </dt>
             <dd>
              与えられた値 value を JSON エンコードして返します。
              <br>
              結果的に、JSON.stringify() と同じです。
              <br>
              JSON オブジェクトが未定義の環境でも互換となるよう実装されています。
              <br>
              serializeToJSON は Pot.Serializer.serializeToJSON として定義されていますが
              Pot.serializeToJSON からも参照できます。
              <pre>var obj = {'Hello\nWorld!': [1, {a: '{ABC}'}]};
debug( serializeToJSON(obj) );
// =&gt; &quot;{\&quot;Hello\\nWorld!\&quot;:[1,{\&quot;a\&quot;:\&quot;{ABC}\&quot;}]}&quot;</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.parseFromJSON"><em>Pot.</em>parseFromJSON</dfn>(text)
             </dt>
             <dd>
              与えられた JSON 文字列 text をデコードして返します。
              <br>
              結果的に、JSON.parse() で処理したことと同じです。
              <br>
              不正な文字やコードが入ってる場合はその値 (キー) を無視します。
              <br>
              JSON オブジェクトが未定義の環境でも互換性がとれるよう実装されています。
              <br>
              parseFromJSON は Pot.Serializer.parseFromJSON として定義されていますが
              Pot.parseFromJSON からも参照できます。
              <pre>
var str = '{&quot;Hello\\u000aWorld!&quot;:[1,{&quot;a&quot;:&quot;{ABC}&quot;}]}';
debug( parseFromJSON(str) );
// =&gt; {'Hello\nWorld!':[1,{a:'{ABC}'}]}</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.serializeToQueryString"><em>Pot.</em>serializeToQueryString</dfn>(params)
             </dt>
             <dd>
              オブジェクトまたは配列で与えられた引数 params をクエリ文字列にして返します。
              <br>
              HTTP GET などで使用される queryString を作成します。
              <br>
              文字列が与えられた場合は、単にそのまま返されます。
              <br>
              serializeToQueryString は Pot.Serializer.serializeToQueryString として定義されていますが
              Pot.serializeToQueryString からも参照できます。
              <pre>var query = {foo: 1, bar: 'bar2', baz: null};
debug( serializeToQueryString(query) );
//  =&gt;  'foo=1&amp;bar=bar2&amp;baz='</pre>
              オブジェクトのキー名として使用できないものを扱う場合は配列 (items 形式) が便利です。
              <pre>// Example of the items format.
var query = [['prototype', 'value1'], ['__iterator__', 'value2']];
debug( serializeToQueryString(query) );
//  =&gt;  'prototype=value1&amp;__iterator__=value2'</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.parseFromQueryString"><em>Pot.</em>parseFromQueryString</dfn>(queryString[, toObject])
             </dt>
             <dd>
              クエリ文字列 queryString を配列またはオブジェクトにデコードして返します。
              <br>
              serializeToQueryString で作成できるクエリ文字列を、
              2 つのアイテムを持つ配列からなる配列にして返します。
              <br>
              引数 toObject が 真 (TRUE) として渡されると、
              キーバリューのペアでなるオブジェクトとして返します。
              <br>
              parseFromQueryString は Pot.Serializer.parseFromQueryString として定義されていますが
              Pot.parseFromQueryString からも参照できます。
              <pre>// Default is the items format.
var query = 'foo=1&amp;bar=bar2&amp;baz=';
debug( parseFromQueryString(query) );
//  =&gt;  [['foo', '1'], ['bar', 'bar2'], ['baz', '']]</pre>
              第二引数 toObject を true で渡した場合はオブジェクトになります。
              <pre>var query = 'key1=value1&amp;key2=value2';
debug( parseFromQueryString(query, true) );
//  =&gt;  {key1: 'value1', key2: 'value2'}</pre>
              次のような for-in などの動作に影響する未知の名前の可能性がある場合は、
              配列で扱うと確実です。
              <pre>var query = 'prototype=value1&amp;__iterator__=value2';
debug( parseFromQueryString(query) );
//  =&gt;  [['prototype', 'value1'], ['__iterator__', 'value2']]</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.urlEncode"><em>Pot.</em>urlEncode</dfn>(string)
             </dt>
             <dd>
              引数 string を URL エンコードして返します。
              <br>
              encodeURIComponent との違いは、
              2 重でエンコードされないことと、
              バイナリ処理などのために
              サロゲートペアによる URIError が発生しないで処理を続行できることです。
              <pre>debug( urlEncode('abc(///)ふぇぇ') );
//    =&gt;    'abc(%2F%2F%2F)%E3%81%B5%E3%81%87%E3%81%87'</pre>
              <pre>// Firefox (SpiderMonkey) では サロゲートペアによる URI Error が発生
//debug( encodeURIComponent('\uD800') ); // Error: malformed URI sequence

// バイナリとみなし処理される
debug( urlEncode('\uD800') ); // '%ED%A0%80'</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.urlDecode"><em>Pot.</em>urlDecode</dfn>(string)
             </dt>
             <dd>
              引数 string を URL デコードして返します。
              <br>
              decodeURIComponent との違いは、
              プラス記号 '+' をスペースに変換する処理が追加されていることです。
              <pre>var s = 'abc(%2F%2F%2F)%E3%81%B5%E3%81%87%E3%81%87';
debug( urlDecode(s) ); // 'abc(///)ふぇぇ'</pre>
              '+' を含むエンコードがされてた場合。
              <pre>var s = '%23foo+.bar+%3Abaz';
debug( decodeURIComponent(s) ); // '#foo+.bar+:baz'
debug( urlDecode(s) );          // '#foo .bar :baz'</pre>
             </dd>
            </dl>
            <p><br></p>
            <h4 id="iteratorFunctions">イテレータ関数</h4>
            <div>
             <p>
              以下はイテレータ関数です。
              Pot.globalize() がされてない状態では Pot.xxx (e.g. Pot.forEach) のように、
              Pot オブジェクトからアクセスできます。
              <br>
              Pot.globalize() が適応されている場合は、
              定義名のままの関数名でも呼び出せます (e.g. forEach)。
              <br>
              Pot.Deferred または Deferred を付けない限り、
              同期で処理が行われます。
              Deferred.xxx としてコールすると、
              非同期になり Pot.Deferred オブジェクトのインスタンスを返します。
              <br>
              例えば forEach (Pot.forEach) は同期処理ですが、
              Deferred.forEach (Pot.Deferred.forEach) は非同期処理です。
              <br>
              引数や処理は同じです。
              <br>
              また、Pot.Deferred のチェイン上で使用する場合、
              第一引数が object などの
              コールバック関数 (callback) でないものは、
              第一引数 (object) がシフトし、
              コールバック関数 (callback) が第一引数となり、
              もともと使われるはずの第一引数 (object) は 
              Deferred コールバックチェインの実行結果にとって代わります。
              <br>
              それ以外は引数の扱いに関して同じです。
             </p>
             <pre>// 同期で実行
forEach([1, 2, 3], function(val) {
    debug(val);
});

// 非同期で実行
Deferred.forEach([1, 2, 3], function(val) {
    debug(val);
});

// 非同期で Pot.Deferred コールバックチェイン上で実行
begin(function() {
    return [1, 2, 3];
}).forEach(function(val) {
    debug(val);
});</pre>
             <p>
              上の例は 3 つとも、1, 2, 3 と同じ出力をします。
             </p>
            </div>
            <dl>
             <dt>
              <dfn id="function.Pot.forEach"><em>Pot.</em>forEach</dfn>(object, callback[, context])
             </dt>
             <dt>
              <dfn id="function.Pot.Deferred.forEach"><em>Pot.</em>Deferred.forEach</dfn>(object, callback[, context])
             </dt>
             <dt>
              <dfn id="function.Pot.Deferred.prototype.forEach"><em>Pot.Deferred.prototype.</em>forEach</dfn>(callback[, context])
             </dt>
             <dd>
              オブジェクトまたは配列をイテレート。
              <br>
              Array.prototype.forEach のようなものです。
              <br>
              context はコールバック内の this になるもの。
              <pre>var a = 0;
forEach([1, 2, 3], function(value, i, array) {
    a += value;
});
debug(a); // 6</pre>
              <pre>var a = '';
forEach({a: 'foo', b: 'bar'}, function(value, key, object) {
    a += key + '=' + value + ',';
});
debug(a); // 'a=foo,b=bar,'</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.repeat"><em>Pot.</em>repeat</dfn>(max, callback[, context])
             </dt>
             <dt>
              <dfn id="function.Pot.Deferred.repeat"><em>Pot.</em>Deferred.repeat</dfn>(max, callback[, context])
             </dt>
             <dt>
              <dfn id="function.Pot.Deferred.prototype.repeat"><em>Pot.Deferred.prototype.</em>repeat</dfn>(callback[, context])
             </dt>
             <dd>
              指定回数ループする。
              <pre>var a = [];
repeat(10, function(i) {
    a.push(i);
});
debug(a); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</pre>
              コールバックの第二引数は、最後のループのみ true となる値が入る。
              <pre>var s = '';
var a = 'abcdef'.split('');
repeat(a.length, function(i, last) {
    s += a[i] + '=' + i + (last ? ';' : ',');
});
debug(s); // 'a=0,b=1,c=2,d=3,e=4,f=5;'</pre>
              第一引数 max は、
              begin, end, step を任意に持つオブジェクトで指定できる。
              <pre>var a = [];
repeat({begin: 0, end: 100, step: 10}, function(i) {
    a.push(i);
});
debug(a); // [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.forEver"><em>Pot.</em>forEver</dfn>(callback[, context])
             </dt>
             <dt>
              <dfn id="function.Pot.Deferred.forEver"><em>Pot.</em>Deferred.forEver</dfn>(callback[, context])
             </dt>
             <dt>
              <dfn id="function.Pot.Deferred.prototype.forEver"><em>Pot.Deferred.prototype.</em>forEver</dfn>(callback[, context])
             </dt>
             <dd>
              StopIteration (Pot.StopIteration) が throw されるまで永久ループ。
              <br>
              コールバックの第一引数に 0 から始まって
              1 ループごとに 1 加算される数値が渡される。
              <pre>var s = '';
var a = 'abc*';
forEver(function(i) {
    s += i + ':' + a;
    if (s.length &gt; 50) {
        throw StopIteration;
    }
});
debug(s);
// '0:abc*1:abc*2:abc*3:abc*4:abc*5:abc*6:abc*7:abc*8:abc*'</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.iterate"><em>Pot.</em>iterate</dfn>(object[, callback[, context]])
             </dt>
             <dt>
              <dfn id="function.Pot.Deferred.iterate"><em>Pot.</em>Deferred.iterate</dfn>(object[, callback[, context]])
             </dt>
             <dt>
              <dfn id="function.Pot.Deferred.prototype.iterate"><em>Pot.Deferred.prototype.</em>iterate</dfn>([callback[, context]])
             </dt>
             <dd>
              Iter (Pot.Iter) オブジェクトのインスタンスをイテレート。
              <br>
              また、yield によるジェネレータをイテレートすることもできます。
              <br>
              <pre>// Pot.Iter インスタンスによるイテレートの例
var results = [];
var iter = new Iter();
iter.next = (function() {
    var i = 0;
    var end = 10;
    return function() {
        if (i &gt;= end) {
            throw StopIteration;
        }
        return i++;
    };
})();
iterate(iter, function(i) {
    results.push(i);
});
debug(results); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</pre>
              yield によるジェネレータを使用する例。
              <pre>var results = [];
var iter = (function() {
    for (var i = 0; i &lt; 10; i++) {
        yield i;
        results.push(i);
    }
})();
iterate(iter);
debug(results); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</pre>
             </dd>
             <dt>
              <em>[new]</em> <dfn id="function.Pot.Iter"><em>Pot.</em>Iter</dfn>()
             </dt>
             <dd>
              Iter (Pot.Iter) コンストラクタ。
              <br>
              next という名前のメソッドを定義することで独自のイテレータが作成できます。
             </dd>
             <dt>
              <dfn id="function.Pot.toIter"><em>Pot.</em>toIter</dfn>(x)
             </dt>
             <dd>
              x を可能な限りイテレート可能な Iter (Pot.Iter) のインスタンスに変換したものを返します。
             </dd>
             <dt>
              <dfn id="function.Pot.items"><em>Pot.</em>items</dfn>(object[, callback[, context]])
             </dt>
             <dt>
              <dfn id="function.Pot.Deferred.items"><em>Pot.</em>Deferred.items</dfn>(object[, callback[, context]])
             </dt>
             <dt>
              <dfn id="function.Pot.Deferred.prototype.items"><em>Pot.Deferred.prototype.</em>items</dfn>([callback[, context]])
             </dt>
             <dd>
              オブジェクト object を 2 つのアイテムからなる配列をもつ配列 (items 形式) に変換します。
              <br>
              オブジェクトのキーは 0 番目の要素に、値は 1 番目の要素に割り当てられます。
              <pre>var obj = {foo: 1, bar: 2, baz: 3};
debug( items(obj) );
//   =&gt;  [['foo', 1], ['bar', 2], ['baz', 3]]</pre>
              配列を対象とした場合。
              <pre>var array = ['foo', 'bar', 'baz'];
debug( items(array) );
//   =&gt;  [[0, 'foo'], [1, 'bar'], [2, 'baz']]</pre>
              コールバック関数を使う例。
              <pre>var obj = {foo: 1, bar: 2, baz: 3};
var callback = function(item) {
    return [item[0] + '::' + item[1]];
};
debug( items(obj, callback) );
//   =&gt;  [['foo::1'], ['bar::2'], ['baz::3']]</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.zip"><em>Pot.</em>zip</dfn>(object[, callback[, context]])
             </dt>
             <dt>
              <dfn id="function.Pot.Deferred.zip"><em>Pot.</em>Deferred.zip</dfn>(object[, callback[, context]])
             </dt>
             <dt>
              <dfn id="function.Pot.Deferred.prototype.zip"><em>Pot.Deferred.prototype.</em>zip</dfn>([callback[, context]])
             </dt>
             <dd>
              与えられた配列 object の各アイテム n 番目の要素からなる配列を作成して返します。
              <br>
              この関数は、Python の zip() のような感じです。
              <pre style="border-color: #999;">引数が以下のような配列とすると、
  [ [1, 2, 3],
    [4, 5, 6] ]

結果は以下のようになります。

  [ [1, 4],
    [2, 5],
    [3, 6] ]</pre>
              各要素を縦に見立てて新しい配列を作ります。
              <br>
              要素数の扱いは「最小」であり、溢れたものは除外されます。
              <pre>var result = zip([[1, 2, 3], [4, 5, 6]]);
debug(result);
//   =&gt;  [[1, 4], [2, 5], [3, 6]]</pre>
              <pre>var result = zip([[1, 2, 3], [1, 2, 3, 4, 5]]);
debug(result);
//   =&gt;  [[1, 1], [2, 2], [3, 3]]</pre>
              <pre>var result = zip([[1], [2], [3]]);
debug(result);
//   =&gt;  [[1, 2, 3]]</pre>
              <pre>var result = zip([[1, 2, 3], ['foo', 'bar', 'baz'], [4, 5]]);
debug(result);
//   =&gt;  [[1, 'foo', 4], [2, 'bar', 5]]</pre>
              コールバック関数を使う例。
              <pre>var callback = function(items) { return items[0] + items[1]; };
var result = zip([[1, 2, 3], [4, 5, 6]], callback);
debug(result);
//   =&gt;  [5, 7, 9]</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.map"><em>Pot.</em>map</dfn>(object, callback[, context])
             </dt>
             <dt>
              <dfn id="function.Pot.Deferred.map"><em>Pot.</em>Deferred.map</dfn>(object, callback[, context])
             </dt>
             <dt>
              <dfn id="function.Pot.Deferred.prototype.map"><em>Pot.Deferred.prototype.</em>map</dfn>(callback[, context])
             </dt>
             <dd>
              与えられた関数 callback を object のすべての要素に対して実行し、
              その結果からなる新しいオブジェクトを生成して返します。
              <br>
              Array.prototype.map のようなものです。
              <pre>function fuzzyPlural(single) {
    return single.replace(/o/g, 'e');
}
var words = ['foot', 'goose', 'moose'];
debug( map(words, fuzzyPlural) );
//    =&gt;    ['feet', 'geese', 'meese']</pre>
              オブジェクトに対しても実行できます。
              <pre>
var object = {foo: 'foo1', bar: 'bar2', baz: 'baz3'};
var result = map(object, function(value, key) {
    return value + '00';
});
debug(result);
//    =&gt;     {foo: 'foo100', bar: 'bar200', baz: 'baz300'}</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.filter"><em>Pot.</em>filter</dfn>(object, callback[, context])
             </dt>
             <dt>
              <dfn id="function.Pot.Deferred.filter"><em>Pot.</em>Deferred.filter</dfn>(object, callback[, context])
             </dt>
             <dt>
              <dfn id="function.Pot.Deferred.prototype.filter"><em>Pot.Deferred.prototype.</em>filter</dfn>(callback[, context])
             </dt>
             <dd>
              object の各値に、
              与えられた関数 callback を実行し、
              その戻り値が真 (TRUE) となるすべての要素からなる
              新しいオブジェクトを生成して返します。
              <br>
              Array.prototype.filter のようなものです。
              <pre>function isBigEnough(value, index, array) {
    return (value &gt;= 10);
}
var filtered = filter([12, 5, 8, 130, 44], isBigEnough);
debug(filtered); // =&gt; [12, 130, 44]</pre>
              オブジェクトに対しても実行できます。
              <pre>function isBigEnough(value, key, object) {
    return (value &gt;= 10);
}
var object = {a: 1, b: 20, c: 7, d: 5, e: 27, f: 99};
var result = filter(object, isBigEnough);
debug(result); // =&gt; {b: 20, e: 27, f: 99}</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.reduce"><em>Pot.</em>reduce</dfn>(object, callback[, initial[, context]])
             </dt>
             <dt>
              <dfn id="function.Pot.Deferred.reduce"><em>Pot.</em>Deferred.reduce</dfn>(object, callback[, initial[, context]])
             </dt>
             <dt>
              <dfn id="function.Pot.Deferred.prototype.reduce"><em>Pot.Deferred.prototype.</em>reduce</dfn>(callback[, initial[, context]])
             </dt>
             <dd>
              object の (左から右へ) 2 つの値に対して
              同時に関数 callback を適用し、単一の値にして返します。
              <br>
              Array.prototype.reduce のようなものです。
              <pre>var array = [1, 2, 3, 4, 5];
var total = reduce(array, function(a, b) { return a + b; });
debug(total); // 15</pre>
              オブジェクトに対して。
              <pre>var object = {a: 1, b: 2, c: 3};
var total = reduce(object, function(a, b) { return a + b; });
debug(total); // 6</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.every"><em>Pot.</em>every</dfn>(object, callback[, context])
             </dt>
             <dt>
              <dfn id="function.Pot.Deferred.every"><em>Pot.</em>Deferred.every</dfn>(object, callback[, context])
             </dt>
             <dt>
              <dfn id="function.Pot.Deferred.prototype.every"><em>Pot.Deferred.prototype.</em>every</dfn>(callback[, context])
             </dt>
             <dd>
              object のすべての要素について
              与えられた関数 callback によって実行した結果が
              真 (TRUE) となる場合 true を返します。
              <br>
              Array.prototype.every のようなものです。
              <pre>function isBigEnough(value, index, array) {
    return (value &gt;= 10);
}
var passed = every([12, 5, 8, 130, 44], isBigEnough);
debug(passed); // false
passed = every([12, 54, 18, 130, 44], isBigEnough);
debug(passed); // true</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.some"><em>Pot.</em>some</dfn>(object, callback[, context])
             </dt>
             <dt>
              <dfn id="function.Pot.Deferred.some"><em>Pot.</em>Deferred.some</dfn>(object, callback[, context])
             </dt>
             <dt>
              <dfn id="function.Pot.Deferred.prototype.some"><em>Pot.Deferred.prototype.</em>some</dfn>(callback[, context])
             </dt>
             <dd>
              object のすべての要素について
              与えられた関数 callback によって実行した結果が
              真 (TRUE) となる要素があるかどうかを調べます。
              あれば true を返します。
              <br>
              Array.prototype.some のようなものです。
              <pre>function isBigEnough(value, index, array) {
    return (value &gt;= 10);
}
var passed = some([2, 5, 8, 1, 4], isBigEnough);
debug(passed); // false
passed = some([12, 5, 8, 1, 4], isBigEnough);
debug(passed); // true</pre>
             </dd>
            </dl>
            <p><br></p>
            <h4 id="PotDeferredMethods">Pot.Deferred のメソッド</h4>
            <div>
              <p>
               以下は、Deferred (Pot.Deferred) のメソッドです。
               <br>
               インスタンスから実行できる、
               つまり Pot.Deferred.prototype メソッドです。
               <br>
               コールバックチェイン上で実行できます。
              </p>
            </div>
            <dl>
             <dt>
              <em>[new]</em> <dfn id="function.Pot.Deferred"><em>Pot.</em>Deferred</dfn>([options])
             </dt>
             <dd>
              Pot.Deferred コンストラクタ。
              <br>
              新しい Deferred インスタンスを作成します。
              <br>
              引数 options に利用できるキーは、
              <dl>
               <dt><em>{Boolean}</em> <dfn>async</dfn></dt>
               <dd>
                同期 (false) / 非同期 (true = default) を設定します。
               </dd>
               <dt><em>{String|Number}</em> <dfn>speed</dfn></dt>
               <dd>
                チェイン間の速度を設定します。
                <br>
                数値 (ミリ秒) で指定、
                または定義された文字列 (<a href="#controlSpeedMap">上の速度の表</a>) で指定できます。
               </dd>
               <dt><em>{Function}</em> <dfn>canceller</dfn></dt>
               <dd>
                cancel() した時に呼び出される関数を設定します。
               </dd>
              </dl>
              <pre>var deferred = new Deferred();</pre>
              <pre>var deferred = new Deferred({ speed : 'slow' });</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.Deferred.prototype.then"><em>Pot.Deferred.prototype.</em>then</dfn>(callback[, errback])
             </dt>
             <dd>
              コールバック関数 callback をチェインに追加します。
              <br>
              関数 errback が与えられると、
              エラーバックとしてチェインに追加します。
              エラーバック関数は rescue で登録することと同じです。
              <br>
              2 つの関数を、成功時、エラー時
              として追加することで手間が省けます。
              <pre>var d = new Deferred();
d.then(function() {
    return someFunc();
}).then(function(res) {
    // 成功時
    debug(res);
}, function(err) {
    // エラー時
    debug(err);
});
d.begin();</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.Deferred.prototype.rescue"><em>Pot.Deferred.prototype.</em>rescue</dfn>(errback)
             </dt>
             <dd>
              エラーバック関数をチェインに追加します。
              <br>
              エラーバックはコールバックチェインで
              エラーが発生したときに、引数にエラーを持ち実行されます。
              <pre>var d = new Deferred();
d.then(function() {
    // エラーを発生させる
    throw new Error('MyError');
}).rescue(function(err) {
    // エラーをキャッチ
    debug(err); // Error: MyError
    return 1;
}).then(function(res) {
    // チェインを継続
    if (res == 1) {
        // 再度エラーを発生させる
        // Error オブジェクトでなくても throw されるとエラー扱い
        throw res;
    }
}).rescue(function(err) {
    // エラーを捕捉
    debug(err); // Error: 1
});
d.begin();</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.Deferred.prototype.ensure"><em>Pot.Deferred.prototype.</em>ensure</dfn>(callback)
             </dt>
             <dd>
              成功時、エラー時どちらでも実行される
              コールバック関数をチェインに追加します。
              <br>
              必ず実行したい場合などに有用です。
              <pre>var d = new Deferred();
d.then(function() {
    // ランダムにエラーを発生させる
    if (Math.random() * 10 &lt; 5) {
        return 'OK';
    } else {
        throw 'NG';
    }
}).ensure(function(res) {
    // エラーが起きても実行される
    if (isError(res)) {
        // なんらかのエラー対処
        return errorHandler();
    } else {
        return res;
    }
}).then(function(res) {
    someFunc(res);
}).begin();</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.Deferred.prototype.begin"><em>Pot.Deferred.prototype.</em>begin</dfn>([value[, ...]])
             </dt>
             <dd>
              コールバックチェインを開始します。
              <br>
              任意に、引数に値を持たせ
              次のコールバック関数の引数に渡すことができます。
              <pre>var d = new Deferred();
d.then(function() {
    debug(1);
    return 1;
});
// この時点ではチェインは実行されていない

// なんらかの条件が通ればコールバック関数を追加
if (check()) {
    d.then(function(res) {
        return someFunc(res);
    });
}
// チェインを実行
d.begin();

// その後は追加した時に実行される
d.then(function(res) {
    return 'hoge';
});
d.then(function(res) {
    debug(res); // 'hoge'
});</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.Deferred.prototype.raise"><em>Pot.Deferred.prototype.</em>raise</dfn>([error[, ...]])
             </dt>
             <dd>
              エラーと共にチェインを開始します。
              <br>
              begin のエラー版のようなものです。
              <br>
              何らかの事情でエラー扱いにしたい時に有用です。
              <pre>var d = new Deferred();
d.then(function() {
    // 成功時
    successFunc();
}).rescue(function(err) {
    // エラー時
    errorFunc(err);
}).ensure(function() {
    // 最終的な処理
    finalFunc();
});
// チェックが通らなければエラーとする
if (!someCheck()) {
    d.raise();
} else {
    d.begin();
}</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.Deferred.prototype.end"><em>Pot.Deferred.prototype.</em>end</dfn>()
             </dt>
             <dd>
              チェインを終了し、閉じます。
              <br>
              終了したチェインは
              then などでコールバックを追加しても実行されません。
              <pre>var d = begin(function() {
    debug(1);
}).then(function() {
    debug(2);
}).end(); // チェインを終了する

// その後に関数を追加しても何も起こらない
d.then(function() {
    debug('Help me!');
});</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.Deferred.prototype.wait"><em>Pot.Deferred.prototype.</em>wait</dfn>(seconds[, value])
             </dt>
             <dd>
              秒単位で待機します。
              <br>
              seconds 秒たつまで次のチェインは実行されません。
              <pre>begin(function() {
    return 1;
}).wait(1).then(function(res) { // 1 秒待つ
    debug(res);
    return res + 1;
}).wait(1.5).then(function(res) { // 1.5 秒待つ
    debug(res); // 2
    return res + 1;
}).wait(0).then(function(res) { // 瞬間的な間隔をおく
    debug(res); // 3
});</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.Deferred.prototype.till"><em>Pot.Deferred.prototype.</em>till</dfn>(cond)
             </dt>
             <dd>
              条件式 cond が 真 (TRUE) を返すまで待機する。
              <br>
              引数 cond は、真偽値を返す関数を指定します。
              <br>
              cond が 真 (TRUE) となる値を返すまで
              次のチェインは実行されません。
              <pre>var d = new Pot.Deferred();
d.then(function() {
    debug('Begin till');
}).till(function() {
    // body が読み込まれるまで待機
    if (!document.body) {
        return false;
    } else {
        return true;
    }
}).then(function() {
    debug('End till');
    document.body.innerHTML += 'hoge';
}).begin();</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.Deferred.prototype.cancel"><em>Pot.Deferred.prototype.</em>cancel</dfn>()
             </dt>
             <dd>
              チェインを中止します。
              <br>
              <pre>var d = new Pot.Deferred();
d.then(function() {
    debug(1);
}).then(function() {
    debug(2);
});
// チェックが通れば開始
if (check()) {
    d.begin();
} else {
    // 通らなければ中止
    d.cancel();
    // キャンセルしたチェインに追加しても何も起きない
    d.then(function() {
        debug('hoge');
    });
    d.begin(); // begin も無視される
}</pre>
              コールバックチェインの中で cancel する場合。
              <pre>begin(function() {
    debug(1);
}).then(function() {
    debug(2);
    // ここでキャンセル
    this.cancel();
}).then(function() {
    // このコールバック関数は実行されない
    debug(3);
});</pre>
              <br>
              チェイン上で実行される
              コールバック関数内の this は、
              自身の Pot.Deferred インスタンスです。
              <br>
             </dd>
             <dt>
              <dfn id="function.Pot.Deferred.prototype.canceller"><em>Pot.Deferred.prototype.</em>canceller</dfn>(func)
             </dt>
             <dd>
              キャンセル時に実行される関数を登録する。
              <br>
              cancel が呼ばれた時に実行される関数を登録します。
              <br>
              canceller はスタッカブルに関数を保持しているため、
              複数の関数を登録することができます。
              <pre>var d = new Deferred();
d.canceller(function() {
    debug('cancelled!');
}).canceller(function() {
    debug('cancelled!!');
}).then(function() {
    debug('start chain');
});
d.cancel();
// cancelled!
// cancelled!!
// と出力される</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.Deferred.prototype.speed"><em>Pot.Deferred.prototype.</em>speed</dfn>(sp)
             </dt>
             <dd>
              各チェイン間の実行速度を設定または取得します。
              <br>
              引数 sp には、文字列定数での速度指定
              またはミリ秒単位の数値で設定します。
              <br>
              定義されている速度値については、
              <a href="#controlSpeedMap">速度の表</a> を参照ください。
              <br>
              引数に何も渡さないでコールすると、現在の速度を返します。
              <pre>var n = 0;
var testFunc = function() { debug(++n); };
var d = new Deferred();
d.then(testFunc).then(testFunc).then(testFunc)
 .then(function() { debug('最も遅い速度に変更 (limp)'); })
 .speed('limp')
 .then(testFunc).then(testFunc).then(testFunc)
 .then(function() { debug('50 ミリ秒に設定'); })
 .speed(50)
 .then(testFunc).then(testFunc).then(testFunc)
 .then(function() { debug('End'); })
 .begin();</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.Deferred.prototype.async"><em>Pot.Deferred.prototype.</em>async</dfn>(sync)
             </dt>
             <dd>
              処理の同期と非同期を切り替え設定します。
              <br>
              デフォルトは非同期です。
              同期にするには false を渡します。
              非同期で実行するには true を渡します。
              <br>
              同期的に実行するには、
              <pre>var d = new Deferred();</pre>
              とコンストラクタから開始した場合のみ適応できます。
              なぜなら Pot.Deferred.begin などの関数は、
              関数内で非同期として new Deferred と生成しているからです。
              最初の実行時に非同期だった場合、同期にしたとしても意味はありません。
              <br>
              または、同期にする場合
              コンストラクタの引数にオプションで、
              <pre>var syncDederred = new Deferred({ async : false });</pre>
              と設定することもできます。
              <pre>var value = null;
var d = new Deferred();
// 同期に設定
d.async(false).then(function() {
    return 'sync';
}).then(function(res) {
    return res + 'hron';
}).then(function(res) {
    return res + 'ous';
}).then(function(res) {
    value = res;
}).begin();

debug(value); // 'synchronous'</pre>
              非同期で実行。
              <pre>var value = null;
var d = new Deferred();
// 非同期に設定
d.async(true).then(function() {
    return 'async';
}).then(function(res) {
    return res + 'hron';
}).then(function(res) {
    return res + 'ous';
}).then(function(res) {
    value = res;
}).begin();

// 非同期のためすぐには取得できない
debug(value); // null

wait(1).then(function() {
    debug(value); // 'asynchronous'
});</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.Deferred.prototype.args"><em>Pot.Deferred.prototype.</em>args</dfn>([...args])
             </dt>
             <dd>
              チェインの結果となる値を設定または取得します。
              <br>
              この値は、前のコールバック関数で return された値です。
              <br>
              args を使用することで、任意の値に設定または上書きできます。
              <pre>var d = new Deferred();
d.then(function(res) {
    debug(res); // undefined
// args により値を設定
}).args('hoge').then(function(res) {
    debug(res); // 'hoge'
    return res + res;
});
d.begin();

d.then(function(res) {
    // 現在の値を取得
    debug( this.args() ); // 'hogehoge'
    // res と同じものです
    debug( this.args() === res ); // true
});

// 分割代入ぽいことするには楽です
d.args(1, 2, 3).then(function(a, b, c) {
    debug(a); // 1
    debug(b); // 2
    debug(c); // 3
});
// 配列でも可
d.args(['A', 'B', 'C']).then(function(a, b, c) {
    debug(a); // 'A'
    debug(b); // 'B'
    debug(c); // 'C'
});</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.Deferred.prototype.data"><em>Pot.Deferred.prototype.</em>data</dfn>([key [, value [, ...args]]])
             </dt>
             <dd>
              現在のチェイン上で使えるストレージとして値を設定または取得する。
              <br>
              実行中の Pot.Deferred のインスタンスに対して、
              自由に設定や取得ができるデータストレージです。
              <br>
              ちょっとした一時的な変数や、
              チェインの外側で定義してチェイン上で使う変数などの省略になります。
              特に、オブジェクトをハッシュとして使うときには代用できます。
              <br>
              設定するときは、第一引数 key にキー名を、
              value に任意の値を渡します。
              <br>
              取得する場合は、設定したキー名を key に渡します。
              対応する値があればそれを返します。
              <pre>var d = new Deferred();
d.data({
    // データを設定する (オブジェクトの場合は引数一つ)
    count : 0,
    begin : 'BEGIN',
    end   : 'END'
}).then(function() {
    // データを取得
    debug( this.data('begin') ); // BEGIN

    return this.data('count') + 1;

}).then(function(res) {
    debug(res); // 1

    // データを更新
    this.data('count', res + 1);

    return this.data('count');
}).then(function(res) {
    debug(res); // 2
    debug( this.data('end') ); // END
});
d.begin();</pre>
             </dd>
            </dl>
            <p><br></p>
            <h4 id="PotDeferredFunctions">Pot.Deferred の関数</h4>
            <div>
              <p>
               以下は、Deferred (Pot.Deferred) オブジェクトの関数です。
               <br>
               static にコールできます。
              </p>
              <p>
               Pot.globalize() がされてない場合は、
               Pot.Deferred.xxx としてコールできます (例えば Pot.Deferred.begin)。
               <br>
               Pot.globalize() が適応されてる場合は、
               定義名のままコールできます (例: begin)。
              </p>
            </div>
            <dl>
             <dt>
              <dfn id="function.Pot.Deferred.succeed"><em>Pot.Deferred.</em>succeed</dfn>([...args])
             </dt>
             <dd>
              コールバックとして発動済みの Pot.Deferred オブジェクトのインスタンスを返す。
              <br>
              発動済みとは、.begin() が実行済みということです。
              ただしコールバック関数自体は 1 つも追加されていないので、
              空の状態で実行済みということです。
              <br>
              なので、then などでコールバック関数を追加すると
              即座に実行します。
              <br>
              引数に何らかの値を渡すと、その値が次のコールバックの引数に渡ります。
              <pre>request('/foo.json').then(function(data) {
    return (

        // 結果が取得できたら次のチェインに繋げるため、
        //  succeed を使用して整合性をとる。
        // 失敗したら別の request により取得する

        data.result ? succeed(data)
                    : request('/bar.json')

    ).then(function(data) {
        // データが取得できる
        return data.result;
    });
}).then(function(res) {
    debug(res);
});</pre>
              用途は様々ですが、一例として上のような場面で
              非 Deferred な値を Deferred 化するために便利です。
             </dd>
             <dt>
              <dfn id="function.Pot.Deferred.failure"><em>Pot.Deferred.</em>failure</dfn>([...args])
             </dt>
             <dd>
              エラーバックとして発動済みの Pot.Deferred オブジェクトのインスタンスを返す。
              <br>
              succeed のエラー版のようなものです。
              空のチェインに対して .raise() が実行済みのインスタンスが返ります。
              <br>
              引数に何らかの値を渡すと、
              その値を Error オブジェクトとして
              次のエラーバックの引数に渡ります。
              <pre>request('foo.json').then(function(data) {
    return (
        data.result ? succeed(data.result) 
                      // 失敗したらエラーとして処理する場合
                    : failure(data)
    ).ensure(function(res) {
        if (isError(res)) {
            // 何らかのエラー処理
            return handleError(res);
        } else {
            // 成功時の処理
            return handleSuccess(res);
        }
    });
}).then(function(res) {
    // 何らかの最終的な処理
    handleEnd(res);
});</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.Deferred.wait"><em>Pot.Deferred.</em>wait</dfn>(seconds[, value])
             </dt>
             <dd>
              秒単位で待機します。
              <br>
              seconds 秒たつまで次のチェインは実行されません。
              <br>
              Pot.Deferred チェイン上での wait() と同じです。
              <br>
              新規の Pot.Deferred インスタンスが返ります。
              value を設定すると、その値を引き継ぎます。
              <pre>// 5 秒後に実行
wait(5).then(function() {
    // 2 秒後に 'fuga' を値として実行
    return wait(2, 'fuga').then(function(res) {
        return 'hoge' + res;
    });
}).then(function(res) {
    debug(res); // 'hogefuga'
});</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.Deferred.till"><em>Pot.Deferred.</em>till</dfn>(cond)
             </dt>
             <dd>
              条件式 cond が 真 (TRUE) を返すまで待機する。
              <br>
              引数 cond は、真偽値を返す関数を指定します。
              <br>
              この関数は Pot.Deferred のインスタンスを返し、
              cond が 真 (TRUE) となる値を返すまで
              返されたインスタンスは実行されません。
              <pre>debug('Begin till');
till(function() {
    // body が読み込まれるまで待機
    if (!document.body) {
        return false;
    } else {
        return true;
    }
}).then(function() {
    debug('End till');
    document.body.innerHTML += 'hoge';
});</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.Deferred.begin"><em>Pot.Deferred.</em>begin</dfn>(func)
             </dt>
             <dd>
              コールバック関数 func を追加した
              Pot.Deferred のインスタンスを作成し、チェインを実行済みにして返します。
              <br>
              <pre>var d = new Deferred();
return d.then(func).begin();</pre>
              上のような流れのショートカットのようなものです。
              <br>
              即座に実行できるため、
              new Deferred と作成する手間が省けます。
              <br>
              返り値のインスタンスは発動済みのため、
              チェインの最後に .begin() とする必要はありません。
              <pre>begin(function() {
    return 1;
}).then(function(res) {
    return res + 1;
}).then(function(res) {
    debug(res); // 2
});</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.Deferred.flush"><em>Pot.Deferred.</em>flush</dfn>(callback[, ...args])
             </dt>
             <dd>
              関数を実行し Pot.Deferred のインスタンスを返します。
              <br>
              begin と似ていますが、
              関数でなくても扱う点が異なります。
              <br>
              callback が Pot.Deferred のインスタンスだった場合は、
              begin() を実行して次のコールバック関数の引数として返します。
              <br>
              それ以外の値だった場合は、そのまま次のコールバックの引数に引き継がれます。
              <pre>flush(function() {
    var d = new Deferred();
    d.then(function() {
        return 'hoge';
    });
    return flush(d).then(function(res) {
        return res + 'fuga';
    }).then(function(res) {
        return flush('piyo').then(function(p) {
            return res + p;
        });
    });
}).then(function(res) {
    debug(res); // 'hogefugapiyo'
});</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.Deferred.maybeDeferred"><em>Pot.Deferred.</em>maybeDeferred</dfn>(x)
             </dt>
             <dd>
              Deferred かどうか分からない値を確実に Deferred インスタンスにして返します。
              <br>
              可能な限り、次のチェインに値が渡せるよう Deferred 化して返します。
              <br>
              何らかの関数の戻り値などが Deferred インスタンスなのかどうか
              曖昧なときなどに有用です。
              <pre>// ランダムに Deferred や Error, 文字列を返す関数
function randomDeferred() {
    var n = Math.random() * 10;
    if (n &lt; 2) {
        return new Error('error');
    } else if (n &lt; 5) {
        return 'string';
    } else if (n &lt; 7) {
        return new Deferred().then(function() {
            return 'unfired';
        });
    } else {
        return begin(function() {
            return 'fired';
        });
    }
}
begin(function() {
    // 不明な値を取得
    var value = randomDeferred();
    // 次のチェインに繋げられるように Deferred 化する
    return maybeDeferred(value);
}).ensure(function(res) {
    debug(res); // (Error: error) or 'string' or 'unfired' or 'fired'
});</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.Deferred.callLater"><em>Pot.Deferred.</em>callLater</dfn>(seconds, callback)
             </dt>
             <dd>
              seconds 秒後に関数 callback を実行します。
              <br>
              Pot.Deferred のインスタンスが返ります。
              返り値の Deferred は、キャンセルすることもできます。
              <br>
              setTimeout の Deferred 版のようなものです。
              そして、ミリ秒ではなく秒数で指定する関数です。
              <pre>callLater(5, function() {
    debug('hoge');
});</pre>
              上の例は、5 秒後に debug 関数により
              コンソールに 'hoge' と出力されます。
             </dd>
             <dt>
              <dfn id="function.Pot.Deferred.callLazy"><em>Pot.Deferred.</em>callLazy</dfn>(callback)
             </dt>
             <dd>
              関数 callback を非同期で実行します。
              <br>
              callLater と似ているところもありますが、
              この関数は callLater(0, function() {...}) とするより速く実行されます。
              <br>
              オーバーヘッドが少ないので、単にバックグラウンドで実行したいときなどに適します。
              (オーバーヘッドに関しては begin のほうがより少ないです。)
              <br>
              返り値は callLater と同様 Deferred になります。
              then などで繋げることもできます。
              <pre>callLazy(function() {
    debug('hoge');
}).then(function() {
    debug('fuga');
});</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.Deferred.isFired"><em>Pot.Deferred.</em>isFired</dfn>(deferred)
             </dt>
             <dd>
              引数 deferred のチェインが開始されているかどうかの真偽値を返します。
              <br>
              すでに開始されている場合は true を返し、
              まだ開始されていない場合は false を返します。
              <pre>var d = new Deferred();
debug( isFired(d) ); // false
d.then(function() {
    return 'hoge';
});
debug( isFired(d) ); // false
d.begin();
debug( isFired(d) ); // true</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.Deferred.lastResult"><em>Pot.Deferred.</em>lastResult</dfn>(deferred)
             </dt>
             <dd>
              引数 deferred の保持している最後の結果値を取得します。
              <br>
              取得したところで、deferred の結果値がなくなるわけではありません。
              通常はコールバック関数の引数として取得できますが、
              何らかの事情で値を確認したい時や、使用したい時に有用です。
              <pre>
var d = new Deferred({ async : false });
d.then(function() {
    return 'foo';
}).then(function(res) {
    return 'bar';
}).then(function(res) {
    return 'baz';
}).begin();
var result = lastResult(d);
debug(result); // 'baz'</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.Deferred.lastError"><em>Pot.Deferred.</em>lastError</dfn>(deferred)
             </dt>
             <dd>
              引数 deferred の保持している最後のエラーを取得します。
              <br>
              lastResult のエラー版のようなものです。
              通常、rescue により取得できるエラーを取得できます。
              <pre>var d = new Deferred({ async : false });
d.then(function() {
  throw new Error('foo');
}).then(function(res) {
  throw new Error('bar');
}).then(function(res) {
  throw new Error('baz');
}).begin();
var result = lastError(d);
debug(result); // Error: foo</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.Deferred.register"><em>Pot.Deferred.</em>register</dfn>(name, func)
             </dt>
             <dd>
              チェインで使用できるユーザー定義のメソッドを登録します。
              <br>
              登録したメソッドは、既存のメソッドと同じく
              コールバックチェイン上で実行することができます。
              <br>
              登録したメソッドは、Pot.Deferred.prototype に影響するため
              すべてのインスタンスで使用できるようになります。
              <pre>// チェインの結果値とメソッドの引数の値を足すメソッドを登録
register('add', function(args) {
    // 引数 args はオブジェクトで渡されます
    //  - args.input  : 登録したメソッドに渡された引数
    //  - args.result : チェインの結果値

    return args.input + args.result;
});

var d = new Pot.Deferred();
d.then(function() {
    return 100;
// 登録したメソッド add を使用し 50 加算する
}).add(50).then(function(res) {
    debug(res); // 150
});
d.begin();</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.Deferred.unregister"><em>Pot.Deferred.</em>unregister</dfn>(name)
             </dt>
             <dd>
              register で登録したメソッドを登録解除します。
              <br>
              <pre>// 上の例 (register) で登録したメソッドを解除
unregister('add');</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.Deferred.deferrize"><em>Pot.Deferred.</em>deferrize</dfn>(object[, method])
             </dt>
             <dd>
              関数を Deferred 化します。
              <br>
              コールバック関数を使用するようなものに対して
              より効果的で、
              非同期であればさらに適しています。
              同期で実行される関数に対しても適応できます。
              <br>
              Deferred 化した関数オブジェクトが返ります。
              返り値の関数の仕様方法、引数などは Deferred 化する前と同じです。
              <br>
              違いは、Pot.Deferred オブジェクトのインスタンスが返る点です。
              <pre>// setTimeout を Deferred 化
var timer = deferrize(window, 'setTimeout');

timer(function() {
    debug('in timer (2000 ms.)');
}, 2000).then(function() {
    debug('End timer');
});</pre>
              同期で実行される関数を Deferred 化。
              <pre>var byId = deferrize(document, 'getElementById');

byId('container').then(function(element) {
    debug('End byId()');
    debug('tagName = ' + element.tagName); // e.g. 'DIV'
});</pre>
              関数を第一引数に直接与えることができます。
              その場合、第二引数は必要ありません。
              <pre>// 文字列を charCode からなる配列に変換する関数
var toCharCode = deferrize(function(string) {
    var chars = [], i, len = string.length;
    for (i = 0; i &lt; len; i++) {
        chars.push(string.charCodeAt(i));
    }
    return chars;
});

var string = 'abcdef';
begin(function() {
    return toCharCode(string).then(function(result) {
        debug(result); // [97, 98, 99, 100, 101, 102]
    });
});</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.Deferred.parallel"><em>Pot.Deferred.</em>parallel</dfn>(deferredList)
             </dt>
             <dd>
              配列またはオブジェクトからなる Deferred のリスト deferredList の、
              すべての結果が揃ってから
              返り値となる Deferred インスタンスを実行します。
              <br>
              この関数により、未知数の Deferred を同時実行 (並列) で処理することができます。
              次のチェインの実行完了を待たずに
              引数の複数コールバックをつぎつぎと実行します。
              すべての結果が揃うと、
              返り値の Pot.Deferred インスタンスを開始します。
              <br>
              MochiKit でいう DeferredList と似ています。
              そして JSDeferred.parallel をベースとしています。
              <pre>// 配列で指定
parallel([
    begin(function() {
        return 'foo';
    }),
    function() {
        return succeed().then(function() {
            return wait(1).then(function() {
                return 'bar';
            });
        });
    },
    (new Deferred()).then(function() {
        return 'baz';
    })
]).then(function(values) {
    debug(values);
    // values[0] == 'foo'
    // values[1] == 'bar'
    // values[2] == 'baz'
});</pre>
              オブジェクトで指定。
              <pre>Pot.Deferred.parallel({
    foo : function() {
        return 1;
    },
    bar : (new Deferred()).then(function() {
        return begin(function() {
            return wait(1).then(function() {
                return succeed(2);
            });
        });
    }),
    baz : function() {
        var d = new Deferred();
        return d.async(false).then(function() {
            return 3;
        });
    }
}).then(function(values) {
    debug(values);
    // values.foo == 1
    // values.bar == 2
    // values.baz == 3
});</pre>
             </dd>
             <dt>
              <dfn id="function.Pot.Deferred.chain"><em>Pot.Deferred.</em>chain</dfn>([...args])
             </dt>
             <dd>
              引数に与えられたチェインと共に新しい Pot.Deferred のインスタンスを作成して返します。
              <br>
              この関数は、
              引数に与えられたコールバック関数または、
              DeferredList となる配列やオブジェクトを
              Deferred インスタンスにコールバックチェインとして追加し、
              それを開始して返り値とします。
              <br>
              つまり、new Deferred から始まって then などで追加していく一連の流れを
              引数の指定みで行えるコンストラクタ代わりに使えます。
              <br>
              chain は、JSDeferred.chain から由来しています。
              <pre>var deferred = chain(
    function() {
        return wait(1).then(function() {
            debug(1);
        });
    },
    function(res) {
        throw new Error('error');
    },
    // 関数名に rescue と付けることで rescue メソッド扱いになる
    function rescue(err) {
        debug(err);
    },
    function(res) {
        return succeed(res).then(function(val) {
            debug(2);
        });
    },
    {
        foo : function(res) {
            debug(3);
        },
        bar : function(res) {
            return begin(function() {
                debug(4);
            });
        }
    },
    function(res) {
        debug(5);
    },
    [
        function(res) {
            return wait(1).then(function() {
                debug(6);
            });
        },
        function(res) {
            return begin(function() {
                return succeed(7).then(function(val) {
                    debug(val);
                });
            });
        }
    ]
);
// 1, (Error: error), 2, 3, 4, 5, 6, 7
// と出力される</pre>
             </dd>
            </dl>
           </div>
           <div>
            <h3 id="otherPropertiesAndMethods">その他のプロパティ</h3>
            <p>
             読み取り専用として、
             Pot.OS, Pot.System, Pot.VERSION, Pot.Browser, Pot.LANG
             などがあります。
             <br>
             いくつか例を示します。
            </p>
            <pre>// OS やデバイスを判別
debug( Pot.OS.win ); // Windows なら true
debug( Pot.OS.iphone ); // iPhone なら true (全て小文字)</pre>
            <pre>if (Pot.Browser.firefox) {
    // ブラウザは Firefox
    debug( Pot.Browser.firefox.version ); // バージョンを出力
}</pre>
            <p>
             などが定義されています。
             <br>
             より詳しくは、(圧縮されてない) ソースコードを参照ください。
            </p>
           </div>
         </div>
        </div>
      </div>
    </div>
    <div class="footer">
      <div style="width: 100%; text-align: right;">
        <p style="margin-right: 2em;">
          <a href="#doc">ページ先頭へ</a>
        </p>
      </div>
      <div style="width: 100%; text-align: center;">
        <div><hr></div>
        <p>
         Last modified: 2011-11-08
         Written by <a href="#contact">polygon planet</a>
        </p>
      </div>
    </div>
  </div>
</body>
</html>